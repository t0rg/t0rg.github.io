// --- CONSTANTES DE L'APPLICATION ---
const MAX_CARDS = 10;
const SOLUCE_PASSWORD = "1111"; // MOT DE PASSE SECRET
const DECKS_KEY = 'torg_game_decks';
const DECK_INFO_KEY = 'torg_game_deck_info';

// Constantes pour le drag/swipe
const SWIPE_THRESHOLD = 80;
const MAX_ROT = 15;
const MAX_DISP = 150;

// --- DONN√âES PAR D√âFAUT (si le localStorage est vide) ---
// M√©tadonn√©es des decks
const DEFAULT_DECK_INFO = [
  { name: "Deck Classic", emoji: "üßúüèª", color: "purple", titleColor: "text-purple-400", cardBorder: "border-purple-400/30", indicatorLeft: "TRANS", indicatorRight: "GIRL" },
  { name: "Deck Hardcore", emoji: "üßöüèª", color: "cyan", titleColor: "text-cyan-400", cardBorder: "border-cyan-400/30", indicatorLeft: "PC", indicatorRight: "CONSOLE" },
  { name: "Deck Cosplay", emoji: "üßùüèª‚Äç‚ôÄÔ∏è", color: "pink", titleColor: "text-pink-400", cardBorder: "border-pink-400/30", indicatorLeft: "COSPLAY", indicatorRight: "IRL" }
];

// MODIFICATION: Les decks initiaux sont maintenant des mod√®les neutres.
const neutralImg = "https://placehold.co/400x550/FBFCF8/000000?text=?";
const neutralCard = (correctSide = "left") => ({
  id: crypto.randomUUID(),
  text: "", // Texte vide
  correct: correctSide,
  img: neutralImg, // Image placeholder
  soluceLink: ""
});

const INITIAL_DECKS = [
  [ // Deck 1 (10 cartes)
    neutralCard("left"),
    neutralCard("right"),
    neutralCard("left"),
    neutralCard("right"),
    neutralCard("left"),
    neutralCard("right"), // 6
    neutralCard("left"),  // 7
    neutralCard("right"), // 8
    neutralCard("left"),  // 9
    neutralCard("right")  // 10
  ],
  [ // Deck 2 (10 cartes)
    neutralCard("left"),
    neutralCard("right"),
    neutralCard("left"),
    neutralCard("right"),
    neutralCard("left"),
    neutralCard("right"), // 6
    neutralCard("left"),  // 7
    neutralCard("right"), // 8
    neutralCard("left"),  // 9
    neutralCard("right")  // 10
  ],
  [ // Deck 3 (10 cartes)
    neutralCard("left"),
    neutralCard("right"),
    neutralCard("left"),
    neutralCard("right"),
    neutralCard("left"),
    neutralCard("right"), // 6
    neutralCard("left"),  // 7
    neutralCard("right"), // 8
    neutralCard("left"),  // 9
    neutralCard("right")  // 10
  ],
];
// FIN DE LA MODIFICATION

// --- GESTION DE L'√âTAT GLOBAL ---
// Les donn√©es de la base de donn√©es persistante (charg√©es au d√©marrage)
let PERSISTENT_DECKS;
let PERSISTENT_DECK_INFO;

// L'√©tat de l'application (r√©initialis√© ou charg√©)
const state = {
  playerName: '',
  currentDeck: 0,
  currentFilter: 'all',
  game: {
    score: 0,
    cardIndex: 0,
    isProcessing: false,
  },
  currentDeckCards: [], // Les 10 cartes tir√©es au sort pour cette partie
  resultsRecap: [],
  isEditingMode: false,
  editingCardGlobalId: null, // ID de la carte en cours d'√©dition
  previousScreen: null, // AJOUT: Pour m√©moriser l'√©cran pr√©c√©dent
  // √âtat du swipe/drag
  drag: {
    startX: 0,
    currentX: 0,
    isDragging: false,
    isMouseDown: false
  }
};

// --- S√âLECTION DES √âL√âMENTS DU DOM ---
// REFACTOR: Objet pour stocker tous les √©l√©ments du DOM
const DOM = {};

/**
 * Point d'entr√©e principal de l'application.
 * S'ex√©cute lorsque le HTML est enti√®rement charg√©.
 */
document.addEventListener('DOMContentLoaded', () => {
  // 1. S√©lectionner tous les √©l√©ments du DOM
  queryDOMElements();
  
  // 2. Charger les donn√©es persistantes (ou les initialiser)
  loadPersistentData();
  
  // 3. Initialiser l'√©tat (ex: nom du joueur)
  state.playerName = localStorage.getItem('player_name') || '';
  if (state.playerName) {
    DOM.playerNameInput.value = state.playerName;
    DOM.playerDisplay.textContent = state.playerName;
  }

  // 4. Configurer tous les auditeurs d'√©v√©nements
  initEventListeners();
  
  // 5. G√©n√©rer le contenu dynamique (listes de decks, galeries...)
  regenerateAllDynamicContent();

  // 6. Afficher l'√©cran d'introduction
  showScreen(DOM.introScreen);
});

/**
 * REFACTOR: S√©lectionne tous les √©l√©ments DOM statiques une seule fois.
 */
function queryDOMElements() {
  // √âcrans
  DOM.introScreen = document.getElementById('intro-screen');
  DOM.deckScreen = document.getElementById('deck-screen');
  DOM.gameScreen = document.getElementById('game-screen');
  DOM.scoresScreen = document.getElementById('scores-screen'); 
  DOM.soluceScreen = document.getElementById('soluce-screen'); 
  DOM.publicSoluceScreen = document.getElementById('public-soluce-screen');
  
  // Header
  DOM.btnHeaderAdmin = document.getElementById('btn-header-admin');
  DOM.playerDisplay = document.getElementById('player-display');

  // Intro
  DOM.playerNameInput = document.getElementById('player-name');
  DOM.btnStart = document.getElementById('btn-start');
  DOM.btnViewScores = document.getElementById('btn-view-scores');

  // S√©lection Deck
  DOM.deckSelectionGrid = document.getElementById('deck-selection-grid');
  DOM.btnViewScoresFromDeck = document.getElementById('btn-view-scores-from-deck');
  DOM.btnViewPublicSoluce = document.getElementById('btn-view-public-soluce');
  DOM.btnChangePlayer = document.getElementById('btn-change-player');
  
  // Jeu
  DOM.overlayLeft = document.getElementById('overlay-left');
  DOM.overlayRight = document.getElementById('overlay-right');
  DOM.scoreDisplay = document.getElementById('score-display');
  DOM.indexDisplay = document.getElementById('index-display');
  DOM.btnQuitGame = document.getElementById('btn-quit-game');
  DOM.cardHolder = document.getElementById('card-holder');
  DOM.indicatorLeft = document.getElementById('indicator-left');
  DOM.indicatorRight = document.getElementById('indicator-right');
  DOM.cardElement = document.getElementById('card');
  DOM.cardImage = document.getElementById('card-image');
  DOM.cardText = document.getElementById('card-text');
  DOM.arrowBtnContainer = document.querySelector('.arrow-btn-container'); // REFACTOR
  DOM.btnArrowLeft = document.getElementById('btn-arrow-left');
  DOM.btnArrowRight = document.getElementById('btn-arrow-right');
  DOM.messageBox = document.getElementById('message-box');
  
  // √âcran de fin
  DOM.endOverlay = document.getElementById('end-overlay');
  DOM.gaugeCircle = document.getElementById('gauge-circle');
  DOM.gaugePercentage = document.getElementById('gauge-percentage');
  DOM.resultMessage = document.getElementById('result-message');
  DOM.recapTitle = document.getElementById('recap-title');
  DOM.recapList = document.getElementById('recap-list');
  DOM.btnChooseDeck = document.getElementById('btn-choose-deck');
  DOM.btnReplay = document.getElementById('btn-replay');
  DOM.btnViewScoresFromGame = document.getElementById('btn-view-scores-from-game');
  
  // √âcran Scores
  DOM.btnBackFromScores = document.getElementById('btn-back-from-scores');
  DOM.scoreFilterButtons = document.getElementById('score-filter-buttons');
  DOM.btnFilterAll = document.getElementById('btn-filter-all'); // REFACTOR: Ajout d'un ID pour le bouton "Tous"
  DOM.scoresList = document.getElementById('scores-list');

  // √âcran Admin (Soluce)
  DOM.btnToggleEdit = document.getElementById('btn-toggle-edit');
  DOM.btnAddDeck = document.getElementById('btn-add-deck');
  // AJOUT DES NOUVEAUX BOUTONS
  DOM.btnExportData = document.getElementById('btn-export-data');
  DOM.btnImportData = document.getElementById('btn-import-data');
  DOM.importFileInput = document.getElementById('import-file-input');
  // FIN AJOUT
  DOM.btnBackFromSoluceAdmin = document.getElementById('btn-back-from-soluce-admin');
  DOM.soluceGalleryContainer = document.getElementById('soluce-gallery-container');
  DOM.soluceInfoText = document.getElementById('soluce-info-text');

  // √âcran Soluce Publique
  DOM.btnBackFromPublicSoluce = document.getElementById('btn-back-from-public-soluce');
  DOM.publicSoluceGalleryContainer = document.getElementById('public-soluce-gallery-container');

  // Modale Image
  DOM.imageModal = document.getElementById('image-modal');
  DOM.modalImage = document.getElementById('modal-image');
  DOM.btnCloseImageModal = document.getElementById('btn-close-image-modal');

  // Modale Mot de Passe
  DOM.passwordModal = document.getElementById('password-modal');
  DOM.passwordInput = document.getElementById('password-input');
  DOM.passwordError = document.getElementById('password-error');
  DOM.btnCheckPassword = document.getElementById('btn-check-password');
  DOM.btnClosePasswordModal = document.getElementById('btn-close-password-modal');

  // Modale √âdition Carte
  DOM.editCardModal = document.getElementById('edit-card-modal');
  DOM.editModalTitle = document.getElementById('edit-modal-title');
  DOM.cardForm = document.getElementById('card-form');
  DOM.editCardDeckIndex = document.getElementById('edit-card-deck-index');
  DOM.editCardId = document.getElementById('edit-card-id');
  DOM.editDeckSelect = document.getElementById('edit-deck-select');
  DOM.editCardText = document.getElementById('edit-card-text');
  DOM.editCardImg = document.getElementById('edit-card-img');
  DOM.editCardSoluceLink = document.getElementById('edit-card-soluce-link');
  DOM.editCardCorrect = document.getElementById('edit-card-correct');
  DOM.saveCardBtn = document.getElementById('save-card-btn');
  DOM.btnDeleteCard = document.getElementById('btn-delete-card');
  DOM.btnCancelEditCard = document.getElementById('btn-cancel-edit-card');

  // Modale √âdition Deck
  DOM.deckModal = document.getElementById('deck-modal');
  DOM.deckForm = document.getElementById('deck-form');
  DOM.deckModalTitle = document.getElementById('deck-modal-title');
  DOM.editDeckId = document.getElementById('edit-deck-id');
  DOM.deckNameInput = document.getElementById('deck-name');
  DOM.deckEmojiInput = document.getElementById('deck-emoji');
  DOM.deckIndicatorLeftInput = document.getElementById('deck-indicator-left');
  DOM.deckIndicatorRightInput = document.getElementById('deck-indicator-right');
  DOM.deckColorSelector = document.getElementById('deck-color-selector');
  DOM.btnSaveDeck = document.getElementById('btn-save-deck');
  DOM.btnCancelDeck = document.getElementById('btn-cancel-deck');
  DOM.btnCloseDeckModal = document.getElementById('btn-close-deck-modal');

  // AJOUT: Nouvelle modale d'alerte/confirmation
  DOM.alertModal = document.getElementById('alert-modal');
  DOM.alertModalTitle = document.getElementById('alert-modal-title');
  DOM.alertModalText = document.getElementById('alert-modal-text');
  DOM.alertModalButtons = document.getElementById('alert-modal-buttons');
  DOM.btnCloseAlertModal = document.getElementById('btn-close-alert-modal');
}

/**
 * REFACTOR: Initialise tous les auditeurs d'√©v√©nements de l'application.
 * Appel√©e une seule fois au d√©marrage.
 */
function initEventListeners() {
  // Header
  DOM.btnHeaderAdmin.addEventListener('click', openPasswordModal);

  // Intro
  DOM.btnStart.addEventListener('click', continueToDecks);
  DOM.btnViewScores.addEventListener('click', () => showScoresScreen(DOM.introScreen));
  
  // S√©lection Deck
  DOM.btnViewScoresFromDeck.addEventListener('click', () => showScoresScreen(DOM.deckScreen));
  DOM.btnViewPublicSoluce.addEventListener('click', showPublicSoluce);
  DOM.btnChangePlayer.addEventListener('click', () => showScreen(DOM.introScreen));

  // Jeu
  DOM.btnQuitGame.addEventListener('click', quitGame);
  
  // CORRECTION: Cet √©couteur est maintenant correctement d√©clench√©
  // apr√®s la correction de onDragEnd.
  DOM.cardElement.addEventListener('click', () => {
    // N'ouvre la modale que si l'image n'est pas le placeholder par d√©faut
    if (DOM.cardImage.src && !DOM.cardImage.src.includes('placehold.co')) {
      openModal(DOM.cardImage.src);
    }
  });
  
  DOM.btnArrowLeft.addEventListener('click', () => handleDecision('left'));
  DOM.btnArrowRight.addEventListener('click', () => handleDecision('right'));
  
  // √âv√©nements de Drag/Swipe
  DOM.cardElement.addEventListener('touchstart', onDragStart, { passive: true });
  DOM.cardElement.addEventListener('touchmove', onDragMove, { passive: true });
  DOM.cardElement.addEventListener('touchend', onDragEnd);
  DOM.cardElement.addEventListener('mousedown', onDragStart);
  document.addEventListener('mousemove', onDragMove); // √âcoute sur tout le document
  document.addEventListener('mouseup', onDragEnd);     // √âcoute sur tout le document
  
  // √âv√©nements de clavier
  document.addEventListener('keydown', onKeyDown);

  // √âcran de fin
  DOM.btnChooseDeck.addEventListener('click', () => {
    DOM.endOverlay.classList.add('hidden');
    showScreen(DOM.deckScreen);
  });
  DOM.btnReplay.addEventListener('click', () => {
    DOM.endOverlay.classList.add('hidden');
    startGame();
  });
  DOM.btnViewScoresFromGame.addEventListener('click', () => showScoresScreen(DOM.gameScreen));

  // √âcran Scores
  DOM.btnBackFromScores.addEventListener('click', () => {
    // Retourne √† l'√©cran m√©moris√©, ou au deckScreen par d√©faut
    showScreen(state.previousScreen || DOM.deckScreen);
  });
  DOM.btnFilterAll.addEventListener('click', (e) => filterScores('all', e.target));

  // √âcran Admin
  DOM.btnToggleEdit.addEventListener('click', toggleEditingMode);
  DOM.btnAddDeck.addEventListener('click', () => openDeckModal(null));
  // AJOUT DES NOUVEAUX √âV√âNEMENTS
  DOM.btnExportData.addEventListener('click', exportData);
  DOM.btnImportData.addEventListener('click', () => DOM.importFileInput.click()); // Ouvre le s√©lecteur de fichier
  DOM.importFileInput.addEventListener('change', importData); // G√®re le fichier s√©lectionn√©
  // FIN AJOUT
  DOM.btnBackFromSoluceAdmin.addEventListener('click', () => showScreen(DOM.deckScreen));

  // √âcran Soluce Publique
  DOM.btnBackFromPublicSoluce.addEventListener('click', () => showScreen(DOM.deckScreen));
  
  // Modale Image
  DOM.imageModal.addEventListener('click', (e) => {
    if (e.target.id === 'image-modal') closeModal(DOM.imageModal);
  });
  DOM.btnCloseImageModal.addEventListener('click', () => closeModal(DOM.imageModal));

  // Modale Mot de Passe
  DOM.passwordModal.addEventListener('click', (e) => {
    if (e.target.id === 'password-modal') closeModal(DOM.passwordModal);
  });
  DOM.btnClosePasswordModal.addEventListener('click', () => closeModal(DOM.passwordModal));
  DOM.btnCheckPassword.addEventListener('click', checkPassword);
  DOM.passwordInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') checkPassword();
  });

  // Modale √âdition Carte
  DOM.editCardModal.addEventListener('click', (e) => {
    if (e.target.id === 'edit-card-modal') closeModal(DOM.editCardModal);
  });
  DOM.saveCardBtn.addEventListener('click', saveCard);
  DOM.btnDeleteCard.addEventListener('click', deleteCard);
  DOM.btnCancelEditCard.addEventListener('click', () => closeModal(DOM.editCardModal));

  // Modale √âdition Deck
  DOM.deckModal.addEventListener('click', (e) => {
    if (e.target.id === 'deck-modal') closeModal(DOM.deckModal);
  });
  DOM.btnCloseDeckModal.addEventListener('click', () => closeModal(DOM.deckModal));
  DOM.btnSaveDeck.addEventListener('click', saveDeckInfo);
  DOM.btnCancelDeck.addEventListener('click', () => closeModal(DOM.deckModal));
  DOM.deckColorSelector.querySelectorAll('.color-swatch').forEach(swatch => {
    swatch.addEventListener('click', () => {
      DOM.deckColorSelector.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
      swatch.classList.add('selected');
    });
  });

  // AJOUT: √âv√©nements pour la nouvelle modale d'alerte
  DOM.alertModal.addEventListener('click', (e) => {
    if (e.target.id === 'alert-modal') closeModal(DOM.alertModal);
  });
  DOM.btnCloseAlertModal.addEventListener('click', () => closeModal(DOM.alertModal));
}

// ------------------------------------
// --- GESTION DU STOCKAGE (localStorage) ---
// ------------------------------------

// CORRECTION: Bloc de fonctions restaur√©
function loadPersistentData() {
  PERSISTENT_DECKS = loadDecks();
  PERSISTENT_DECK_INFO = loadDeckInfo();
}

function loadDecks() {
  const storedDecks = localStorage.getItem(DECKS_KEY);
  if (storedDecks) {
    try {
      return JSON.parse(storedDecks);
    } catch (e) {
      console.error("Erreur lors du chargement des decks, r√©initialisation.");
      return migrateInitialDecks();
    }
  }
  return migrateInitialDecks();
}

function loadDeckInfo() {
  const storedInfo = localStorage.getItem(DECK_INFO_KEY);
  if (storedInfo) {
    try {
      return JSON.parse(storedInfo);
    } catch (e) {
      return migrateInitialDeckInfo();
    }
  }
  return migrateInitialDeckInfo();
}

function migrateInitialDecks() {
  const decksWithIds = INITIAL_DECKS.map(deck => 
    deck.map(card => ({
      ...card, 
      id: card.id || crypto.randomUUID(),
      soluceLink: card.soluceLink || ""
    }))
  );
  saveDecks(decksWithIds); // Sauvegarde directe
  return decksWithIds;
}

function migrateInitialDeckInfo() {
  saveDeckInfoToStorage(DEFAULT_DECK_INFO); // Sauvegarde directe
  return DEFAULT_DECK_INFO;
}

function saveDecks(decks) {
  localStorage.setItem(DECKS_KEY, JSON.stringify(decks));
}

function saveDeckInfoToStorage(info) {
  localStorage.setItem(DECK_INFO_KEY, JSON.stringify(info));
}
// FIN DU BLOC RESTAUR√â

function getScores() {
  return JSON.parse(localStorage.getItem('game_scores') || '[]');
}

// ------------------------------------
// --- IMPORT/EXPORT DES DONN√âES ---
// ------------------------------------

/**
 * Exporte toutes les donn√©es des decks (cartes et infos)
 * dans un fichier JSON t√©l√©chargeable.
 */
function exportData() {
  console.log("Exportation des donn√©es...");
  try {
    // 1. Cr√©er l'objet de donn√©es
    const data = {
      decks: PERSISTENT_DECKS,
      info: PERSISTENT_DECK_INFO
    };
    
    // 2. Convertir en cha√Æne JSON (avec formatage pour lisibilit√©)
    const dataString = JSON.stringify(data, null, 2);
    
    // 3. Cr√©er un Blob (fichier en m√©moire)
    const blob = new Blob([dataString], { type: 'application/json' });
    
    // 4. Cr√©er un lien de t√©l√©chargement
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    // G√©n√®re un nom de fichier avec la date, ex: torg_beta_backup_2025-11-09.json
    a.download = `torg_beta_backup_${new Date().toISOString().split('T')[0]}.json`;
    
    // 5. Simuler le clic, t√©l√©charger, puis nettoyer
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
  } catch (error) {
    console.error("Erreur lors de l'exportation:", error);
    // REMPLACEMENT: alert -> showAlert
    showAlert("Erreur", "√âchec de l'exportation des donn√©es.", "error");
  }
}

/**
 * G√®re l'importation d'un fichier JSON de donn√©es.
 * Appel√© par l'√©v√©nement 'change' de l'input file.
 * @param {Event} event - L'√©v√©nement de changement de l'input file.
 */
function importData(event) {
  const file = event.target.files[0];
  if (!file) {
    console.log("Aucun fichier s√©lectionn√©.");
    return;
  }
  
  const reader = new FileReader();
  
  reader.onload = (e) => {
    try {
      // 1. Lire et analyser le contenu du fichier
      const content = e.target.result;
      const data = JSON.parse(content);
      
      // 2. Valider la structure du fichier
      if (data && Array.isArray(data.decks) && Array.isArray(data.info)) {
        
        const totalDecks = data.info.length;
        const totalCards = data.decks.reduce((sum, deck) => sum + (deck ? deck.length : 0), 0);
        
        // 3. REMPLACEMENT: confirm -> showConfirm (logique asynchrone)
        
        // √âtape 3a: D√©finir ce qu'il faut faire si l'utilisateur confirme
        const onConfirmImport = () => {
          // 4. Sauvegarder les nouvelles donn√©es dans localStorage
          saveDecks(data.decks);
          saveDeckInfoToStorage(data.info);
          
          // 5. Recharger l'√©tat de l'application et rafra√Æchir l'interface
          loadPersistentData(); // Met √† jour les variables globales
          regenerateAllDynamicContent(); // Redessine toute l'UI
          
          // REMPLACEMENT: alert -> showAlert
          showAlert("Importation R√©ussie", "Les nouveaux decks sont charg√©s.", "success");
        };
        
        // √âtape 3b: Afficher la modale de confirmation
        showConfirm(
          "Confirmer l'importation",
          `Vous allez importer ${totalDecks} deck(s) et ${totalCards} carte(s).\n\nATTENTION: Cela √©crasera et remplacera toutes les donn√©es actuelles. Continuer ?`,
          onConfirmImport
        );
        
      } else {
        throw new Error("Structure de fichier invalide. Le JSON doit contenir les cl√©s 'decks' et 'info' (tableaux).");
      }
    } catch (error) {
      console.error("Erreur lors de l'importation:", error);
      // REMPLACEMENT: alert -> showAlert
      showAlert("Erreur d'importation", `√âchec: ${error.message}`, "error");
    } finally {
      // R√©initialiser le champ de fichier pour permettre de r√©importer le m√™me fichier
      event.target.value = null;
    }
  };
  
  reader.onerror = (error) => {
     console.error("Erreur de lecture du fichier:", error);
     // REMPLACEMENT: alert -> showAlert
     showAlert("Erreur", "√âchec de la lecture du fichier.", "error");
     event.target.value = null;
  };
  
  reader.readAsText(file);
}

// ------------------------------------
// --- NAVIGATION & GESTION DES √âCRANS ---
// ------------------------------------

function showScreen(screenEl) {
  const mainScreens = [
    DOM.introScreen, DOM.deckScreen, DOM.gameScreen, 
    DOM.scoresScreen, DOM.soluceScreen, DOM.publicSoluceScreen
  ];
  
  mainScreens.forEach(s => {
    s.classList.add('hidden-screen');
    // s.style.opacity = 0; // Opacit√© g√©r√©e par 'hidden-screen'
  });

  // S'assurer que les modales sont cach√©es
  closeModal(DOM.imageModal);
  closeModal(DOM.passwordModal);
  closeModal(DOM.editCardModal);
  closeModal(DOM.deckModal);
  closeModal(DOM.alertModal); // AJOUT

  screenEl.classList.remove('hidden-screen');
  // requestAnimationFrame(() => screenEl.style.opacity = 1); // Plus n√©cessaire
}

function showScoresScreen(prevScreen) {
  state.previousScreen = prevScreen; // M√©morise l'√©cran d'o√π on vient
  renderScores();
  showScreen(DOM.scoresScreen);
}

function showAllSoluce() {
  // Montre tous les titres et conteneurs
  DOM.soluceGalleryContainer.querySelectorAll('.soluce-deck-title').forEach(el => el.style.display = 'flex');
  DOM.soluceGalleryContainer.querySelectorAll('.soluce-deck-content').forEach(el => {
    el.classList.remove('hidden-soluce');
  });
  
  state.isEditingMode = false;
  updateSoluceDisplayModes(); // R√©initialise les modes
  showScreen(DOM.soluceScreen);
}

function showPublicSoluce() {
  regeneratePublicSoluce(); // S'assure que la galerie publique est √† jour
  showScreen(DOM.publicSoluceScreen);
}

// ------------------------------------
// --- G√âN√âRATION D'UI DYNAMIQUE ---
// ------------------------------------

/**
 * REFACTOR: Fonction centrale pour (re)g√©n√©rer tout le contenu
 * d√©pendant des donn√©es persistantes.
 */
function regenerateAllDynamicContent() {
  generateDeckSelectionScreen();
  generateSoluceContainers();
  generatePublicSoluceContainers();
  generateScoreFilters();
  
  // Met √† jour la liste des decks dans la modale d'√©dition
  DOM.editDeckSelect.innerHTML = '';
  PERSISTENT_DECK_INFO.forEach((info, index) => {
    DOM.editDeckSelect.innerHTML += `<option value="${index}">${info.emoji} ${info.name}</option>`;
  });
}

/**
 * REFACTOR: Renomm√©e pour √™tre plus claire.
 * Utilise `document.createElement` pour plus de s√©curit√© et de clart√©.
 */
function regeneratePublicSoluce() {
  generatePublicSoluceContainers();
}

function generateDeckSelectionScreen() {
  DOM.deckSelectionGrid.innerHTML = ''; // Vide la grille
  
  PERSISTENT_DECK_INFO.forEach((deckInfo, index) => {
    const cardCount = (PERSISTENT_DECKS[index] || []).length;
    
    const el = document.createElement('div');
    el.className = `deck-card glass rounded-xl p-6 border-2 ${deckInfo.cardBorder}`;
    el.addEventListener('click', () => selectDeck(index));
    
    el.innerHTML = `
      <div class="text-4xl mb-4 text-center">${deckInfo.emoji}</div>
      <h3 class="text-xl font-bold mb-2 text-center ${deckInfo.titleColor}">${deckInfo.name}</h3>
      <p class="text-sm text-gray-300 text-center mb-3">Le deck ${deckInfo.name.toLowerCase()}</p>
      <div class="text-xs text-gray-400 text-center">${cardCount} cartes</div>
    `;
    DOM.deckSelectionGrid.appendChild(el);
  });
}

function generateScoreFilters() {
  // Vider les anciens filtres (sauf le bouton 'Tous')
  DOM.scoreFilterButtons.querySelectorAll('.filter-btn:not(#btn-filter-all)').forEach(btn => btn.remove());
  
  PERSISTENT_DECK_INFO.forEach((deckInfo, index) => {
    const btn = document.createElement('button');
    btn.className = 'filter-btn px-4 py-2 bg-white/6 border border-white/10 rounded-lg text-sm';
    btn.textContent = `${deckInfo.emoji} ${deckInfo.name}`;
    btn.addEventListener('click', (e) => filterScores(index, e.target));
    DOM.scoreFilterButtons.appendChild(btn);
  });
}

/**
 * REFACTOR: Utilise `createElement` pour cr√©er les vignettes.
 * C'est plus verbeux mais beaucoup plus propre.
 */
function generateSoluceContainers() {
  DOM.soluceGalleryContainer.innerHTML = ''; // Nettoyer l'ancien contenu

  PERSISTENT_DECKS.forEach((deck, deckIndex) => {
    const deckInfo = PERSISTENT_DECK_INFO[deckIndex];
    if (!deckInfo) {
      console.warn(`Pas d'info pour le deck ${deckIndex}, le deck sera ignor√©.`);
      return;
    }
    
    // Cr√©e le titre du Deck
    const titleEl = document.createElement('h4');
    titleEl.className = `soluce-deck-title ${deckInfo.titleColor}`;
    titleEl.innerHTML = `${deckInfo.emoji} ${deckInfo.name} (${(deck || []).length} cartes)`;
    
    const editBtn = document.createElement('span');
    editBtn.className = 'edit-deck-btn';
    editBtn.innerHTML = '‚úèÔ∏è';
    editBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      openDeckModal(deckIndex);
    });
    titleEl.appendChild(editBtn);
    DOM.soluceGalleryContainer.appendChild(titleEl);

    // Cr√©e le conteneur sp√©cifique du Deck
    const cardsContainer = document.createElement('div');
    cardsContainer.id = `soluce-deck-${deckIndex}`;
    cardsContainer.className = 'soluce-deck-content hidden-soluce';
    DOM.soluceGalleryContainer.appendChild(cardsContainer);
    
    // Ajoute les cartes
    (deck || []).forEach(card => {
      cardsContainer.appendChild(createSoluceCardVignette(card, deckInfo, deckIndex));
    });
    
    // Ajoute le bouton "Ajouter une carte"
    cardsContainer.appendChild(createAddCardVignette(deckIndex));
  });
  
  updateSoluceDisplayModes();
}

function generatePublicSoluceContainers() {
  DOM.publicSoluceGalleryContainer.innerHTML = ''; // Nettoyer l'ancien contenu

  PERSISTENT_DECKS.forEach((deck, deckIndex) => {
    const deckInfo = PERSISTENT_DECK_INFO[deckIndex];
    if (!deckInfo) return; // Ignore les decks sans info
    
    // Cr√©e le titre du Deck
    const titleEl = document.createElement('h4');
    titleEl.className = `soluce-deck-title ${deckInfo.titleColor}`;
    titleEl.innerHTML = `${deckInfo.emoji} ${deckInfo.name} (${(deck || []).length} cartes)`;
    DOM.publicSoluceGalleryContainer.appendChild(titleEl);

    // Cr√©e le conteneur sp√©cifique du Deck
    const cardsContainer = document.createElement('div');
    cardsContainer.className = 'soluce-deck-content';
    DOM.publicSoluceGalleryContainer.appendChild(cardsContainer);
    
    // Ajoute les cartes (en mode public/consultation)
    (deck || []).forEach(card => {
      cardsContainer.appendChild(createSoluceCardVignette(card, deckInfo, deckIndex, true));
    });
  });
}

/**
 * REFACTOR: Cr√©e une vignette de carte pour la galerie (Admin ou Publique)
 * @param {object} card - L'objet carte
 * @param {object} deckInfo - Les m√©tadonn√©es du deck
 * @param {number} deckIndex - L'index du deck
 * @param {boolean} [isPublic=false] - Si vrai, g√©n√®re une vignette publique (sans √©dition)
 */
function createSoluceCardVignette(card, deckInfo, deckIndex, isPublic = false) {
  const el = document.createElement('div');
  el.className = 'soluce-gallery-item flex flex-col justify-between p-2 glass rounded-lg border-2 ' + deckInfo.cardBorder;
  el.setAttribute('data-card-id', card.id);
  el.setAttribute('data-deck-index', deckIndex);
  
  const hasSoluceLink = card.soluceLink && card.soluceLink.trim() !== "";
  
  // Gestion du clic
  el.addEventListener('click', () => {
    if (!isPublic && state.isEditingMode) {
      openEditModal(deckIndex, card.id);
    } else if (hasSoluceLink) {
      window.open(card.soluceLink, '_blank');
    } else {
      openModal(card.img);
    }
  });
  
  // Conteneur d'image (pour le fond)
  const imageContainer = document.createElement('div');
  imageContainer.className = 'w-full h-2/3 object-cover rounded-md mb-1 soluce-gallery-item-image-container';
  imageContainer.style.backgroundImage = `url('${card.img}')`;
  imageContainer.style.backgroundSize = 'cover';
  imageContainer.style.backgroundPosition = 'center';

  if (hasSoluceLink) {
    imageContainer.innerHTML = `<span class="soluce-link-indicator">üîó</span>`;
  }
  
  const correctText = card.correct === 'left' ? 'GAUCHE (Mauve)' : 'DROITE (Rose)';
  const colorClass = card.correct === 'left' ? 'text-purple-400' : 'text-pink-400';
  
  const textDiv = document.createElement('div');
  textDiv.className = 'text-xs font-semibold text-gray-200 truncate';
  textDiv.title = card.text;
  textDiv.textContent = card.text.split(' (')[0] || "Carte sans texte"; // Fallback
  
  const correctDiv = document.createElement('div');
  correctDiv.className = `text-[10px] ${colorClass}`;
  correctDiv.textContent = `R√©p: ${correctText}`;
  
  const deckNameDiv = document.createElement('div');
  deckNameDiv.className = 'text-[9px] text-gray-400 mt-0.5';
  deckNameDiv.textContent = deckInfo.name;
  
  el.appendChild(imageContainer);
  el.appendChild(textDiv);
  el.appendChild(correctDiv);
  el.appendChild(deckNameDiv);
  
  return el;
}

/**
 * REFACTOR: Cr√©e la vignette "+" pour ajouter une carte
 * @param {number} deckIndex - L'index du deck auquel ajouter la carte
 */
function createAddCardVignette(deckIndex) {
  const addCardEl = document.createElement('div');
  addCardEl.className = 'soluce-gallery-item add-card-btn';
  addCardEl.style.display = 'none'; // Cach√© par d√©faut
  addCardEl.addEventListener('click', () => openEditModal(deckIndex, null));
  addCardEl.innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
    </svg>
  `;
  return addCardEl;
}

// ------------------------------------
// --- LOGIQUE DU JEU ---
// ------------------------------------

function continueToDecks() {
  const name = (DOM.playerNameInput.value || '').trim();
  if (!name) {
    DOM.playerNameInput.focus();
    DOM.playerNameInput.classList.add('border-red-500');
    return;
  }
  DOM.playerNameInput.classList.remove('border-red-500');
  state.playerName = name;
  localStorage.setItem('player_name', state.playerName);
  DOM.playerDisplay.textContent = state.playerName;
  showScreen(DOM.deckScreen);
}

function selectDeck(deckIndex) {
  // V√©rifie si le deck a assez de cartes
  if (!PERSISTENT_DECKS[deckIndex] || PERSISTENT_DECKS[deckIndex].length < MAX_CARDS) {
    showAlert(
      "Deck incomplet",
      `Ce deck n'a que ${PERSISTENT_DECKS[deckIndex]?.length || 0} cartes. Il en faut au moins ${MAX_CARDS} pour jouer.`,
      "warning"
    );
    return;
  }
  state.currentDeck = deckIndex;
  startGame();
}

function startGame() {
  state.resultsRecap = []; // R√©initialise les r√©sultats
  
  const fullDeck = PERSISTENT_DECKS[state.currentDeck];
  const shuffledDeck = shuffleArray(fullDeck);
  
  // Stocke une r√©f√©rence ID unique
  state.currentDeckCards = shuffledDeck.slice(0, MAX_CARDS).map(c => ({ id: c.id })); 
  
  // AJOUT: Pr√©charger les images du jeu
  preloadGameImages(state.currentDeckCards);
  
  state.game = { score: 0, cardIndex: 0, isProcessing: false };
  updateUI();
  displayCard();
  showScreen(DOM.gameScreen);
}

/**
 * AJOUT: Pr√©charge les images pour la partie en cours.
 * @param {Array} cardRefs - Tableau des r√©f√©rences de cartes (ex: [{id: '...'}])
 */
function preloadGameImages(cardRefs) {
  const fullDeck = PERSISTENT_DECKS[state.currentDeck];
  
  cardRefs.forEach(ref => {
    const card = fullDeck.find(c => c.id === ref.id);
    if (card && card.img) {
      const img = new Image(); // Cr√©e un objet Image en m√©moire
      img.src = card.img;       // D√©clenche le t√©l√©chargement
    }
  });
}

function endGame() {
  state.game.isProcessing = true;
  const pct = Math.round((state.game.score / MAX_CARDS) * 100);
  saveScore(state.playerName, state.currentDeck, state.game.score, pct);
  displayErrorRecap(); // Affiche le r√©capitulatif
  updateUI(); // Met √† jour l'UI (qui masquera la carte)
  state.game.isProcessing = false;
  DOM.endOverlay.classList.remove('hidden');
  // DOM.endOverlay.style.opacity = 1; // Plus n√©cessaire
  
  // Animer la jauge
  const circumference = 2 * Math.PI * 80;
  const offset = circumference - (pct / 100) * circumference;
  setTimeout(() => DOM.gaugeCircle.style.strokeDashoffset = offset, 100);
  
  DOM.gaugePercentage.textContent = pct + '%';
  const result = getResultMessage(pct);
  DOM.resultMessage.textContent = result.text;
  DOM.resultMessage.className = `result-message text-2xl font-bold mb-4 px-4 py-3 rounded-lg ${result.color}`;
}

function quitGame() {
  showScreen(DOM.deckScreen);
}

function handleDecision(decision) {
  if (state.game.isProcessing || state.game.cardIndex >= MAX_CARDS) return;
  state.game.isProcessing = true;
  
  const currentCardRef = state.currentDeckCards[state.game.cardIndex];
  const cur = PERSISTENT_DECKS[state.currentDeck].find(c => c.id === currentCardRef.id);
  
  // Si la carte n'existe plus (ex: supprim√©e pendant le jeu), on passe
  if (!cur) {
    state.game.cardIndex++;
    state.game.isProcessing = false;
    displayCard(); // Affiche la carte suivante
    return;
  }

  const isCorrect = decision === cur.correct; 
  
  // Stocke le r√©sultat
  currentCardRef.isCorrect = isCorrect; 
  currentCardRef.img = cur.img;
  currentCardRef.text = cur.text;
  state.resultsRecap.push(currentCardRef);
  
  if (!isCorrect) {
    state.game.score++;
    DOM.cardElement.style.borderColor = '#EF4444'; // Rouge
  } else {
    DOM.cardElement.style.borderColor = '#10B981'; // Vert
  }
  
  // Feedback visuel (d√©grad√©)
  if (decision === 'left') {
    DOM.overlayLeft.style.opacity = '0.5';
    DOM.overlayLeft.style.transition = 'opacity 0.2s ease-out';
  } else {
    DOM.overlayRight.style.opacity = '0.5';
    DOM.overlayRight.style.transition = 'opacity 0.2s ease-out';
  }
  
  const slideClass = decision === 'left' ? 'slide-out-left' : 'slide-out-right';
  DOM.cardElement.classList.add(slideClass);
  
  setTimeout(() => {
    DOM.cardElement.classList.remove(slideClass);
    state.game.cardIndex++;
    
    // R√©initialisation des d√©grad√©s
    DOM.overlayLeft.style.opacity = '0';
    DOM.overlayRight.style.opacity = '0';
    DOM.overlayLeft.style.transition = 'opacity 0.1s linear';
    DOM.overlayRight.style.transition = 'opacity 0.1s linear';
    
    if (state.game.cardIndex < MAX_CARDS) {
      updateUI();
      displayCard();
      state.game.isProcessing = false;
    } else {
      endGame();
    }
  }, 360);
}

// ------------------------------------
// --- LOGIQUE DE DRAG/SWIPE ---
// ------------------------------------

function onDragStart(e) {
  if (state.game.isProcessing || state.game.cardIndex >= MAX_CARDS || isModalOpen()) return;

  if (e.type === 'mousedown') {
    state.drag.isMouseDown = true;
    state.drag.startX = e.clientX;
    e.preventDefault(); // Emp√™che la s√©lection de texte
  } else { // touchstart
    state.drag.isDragging = true;
    state.drag.startX = e.touches[0].clientX;
  }
  
  state.drag.currentX = state.drag.startX;
  DOM.cardElement.style.transition = 'none'; 
  DOM.cardElement.style.cursor = 'grabbing';
}

function onDragMove(e) {
  if (state.game.isProcessing || isModalOpen() || (!state.drag.isMouseDown && !state.drag.isDragging)) return;

  if (e.type === 'mousemove') {
    state.drag.currentX = e.clientX;
  } else { // touchmove
    state.drag.currentX = e.touches[0].clientX;
  }
  
  const dx = state.drag.currentX - state.drag.startX;
  let rot = (dx / MAX_DISP) * MAX_ROT;
  rot = Math.max(-MAX_ROT, Math.min(MAX_ROT, rot));
  
  DOM.cardElement.style.transform = `translateX(${dx}px) rotate(${rot}deg)`;
  updateVisualFeedback(dx); 
}

// CORRECTION: La logique de onDragEnd est modifi√©e pour 
// mieux faire la distinction entre un clic et un glissement.
function onDragEnd(e) {
  if (state.game.isProcessing || isModalOpen() || (!state.drag.isMouseDown && !state.drag.isDragging)) return;

  const isMouseUp = e.type === 'mouseup';
  if (isMouseUp) {
    state.drag.isMouseDown = false;
  } else { // touchend
    state.drag.isDragging = false;
  }

  DOM.cardElement.style.cursor = 'grab';
  const dx = state.drag.currentX - state.drag.startX;
  state.drag.startX = 0;
  
  DOM.cardElement.style.transition = 'transform .35s cubic-bezier(.22,.9,.27,1), opacity .35s, border-color .3s'; 
  updateVisualFeedback(0); 
  
  // CORRECTION: Si le mouvement est faible, c'est un clic/tap.
  // On le remet en place et ON NE FAIT RIEN D'AUTRE.
  // L'√©v√©nement 'click' (de initEventListeners) s'en chargera.
  if (Math.abs(dx) < 10) { 
    DOM.cardElement.style.transform = 'none'; // Snap back
    return; // Laisse l'√©v√©nement 'click' se d√©clencher
  }
  
  // Si le mouvement est suffisant, c'est un swipe
  if (dx > SWIPE_THRESHOLD) handleDecision('right');
  else if (dx < -SWIPE_THRESHOLD) handleDecision('left');
  else DOM.cardElement.style.transform = 'none';
}

function onKeyDown(e) {
  // G√©rer les touches fl√©ch√©es pour le jeu
  if (!DOM.gameScreen.classList.contains('hidden-screen')) {
    if (isModalOpen()) return; // Ne pas jouer si une modale est ouverte
    if (e.key === 'ArrowLeft') handleDecision('left');
    if (e.key === 'ArrowRight') handleDecision('right');
  }
  
  // G√©rer la touche √âchap pour fermer les modales
  if (e.key === 'Escape') {
    if (DOM.imageModal.classList.contains('active')) closeModal(DOM.imageModal);
    else if (DOM.passwordModal.classList.contains('active')) closeModal(DOM.passwordModal);
    else if (DOM.editCardModal.classList.contains('active')) closeModal(DOM.editCardModal);
    else if (DOM.deckModal.classList.contains('active')) closeModal(DOM.deckModal);
    else if (DOM.alertModal.classList.contains('active')) closeModal(DOM.alertModal); // AJOUT
  }
}


// ------------------------------------
// --- FONCTIONS ADMIN & √âDITION ---
// ------------------------------------

function checkPassword() {
  const inputCode = DOM.passwordInput.value;
  if (inputCode === SOLUCE_PASSWORD) {
    closeModal(DOM.passwordModal);
    showAllSoluce(); // Affiche la soluce compl√®te
  } else {
    DOM.passwordError.classList.remove('hidden');
    DOM.passwordInput.value = '';
    DOM.passwordInput.focus();
  }
}

function toggleEditingMode() {
  state.isEditingMode = !state.isEditingMode;
  updateSoluceDisplayModes();
}

function updateSoluceDisplayModes() {
  // Met √† jour les vignettes de carte
  DOM.soluceGalleryContainer.querySelectorAll('.soluce-gallery-item:not(.add-card-btn)').forEach(item => {
    item.classList.toggle('editing-mode', state.isEditingMode);
  });
  
  // Met √† jour les boutons
  DOM.btnToggleEdit.textContent = state.isEditingMode ? "Quitter l'√©dition" : "Activer l'√©dition";
  DOM.btnAddDeck.style.display = state.isEditingMode ? 'block' : 'none';
  DOM.btnExportData.style.display = state.isEditingMode ? 'block' : 'none';
  DOM.btnImportData.style.display = state.isEditingMode ? 'block' : 'none';
  
  DOM.soluceGalleryContainer.querySelectorAll('.add-card-btn').forEach(btn => {
    btn.style.display = state.isEditingMode ? 'flex' : 'none';
  });
  DOM.soluceGalleryContainer.querySelectorAll('.edit-deck-btn').forEach(btn => {
    btn.style.display = state.isEditingMode ? 'inline' : 'none';
  });

  // Met √† jour le texte d'information
  if (state.isEditingMode) {
    DOM.soluceInfoText.textContent = "Mode √âDITION ACTIF : Cliquez sur une carte pour la modifier ou la supprimer, ou utilisez le bouton 'Ajouter une carte'.";
  } else {
    DOM.soluceInfoText.textContent = "Mode CONSULTATION : Cliquez sur une vignette pour agrandir l'image. Si un lien Soluce (üîó) est pr√©sent, le clic ouvrira le lien.";
  }
}

function openEditModal(deckIndex, cardId = null) {
  state.editingCardGlobalId = cardId;
  DOM.passwordModal.classList.remove('active');

  if (cardId === null) {
    // MODE AJOUT
    DOM.editModalTitle.textContent = 'Ajouter une nouvelle carte';
    DOM.editCardId.value = '';
    DOM.editCardText.value = '';
    DOM.editCardImg.value = '';
    DOM.editCardSoluceLink.value = '';
    DOM.editCardCorrect.value = 'left';
    DOM.editDeckSelect.value = deckIndex !== null ? deckIndex.toString() : '0';
    DOM.editDeckSelect.disabled = false;
    DOM.btnDeleteCard.style.display = 'none';
  } else {
    // MODE √âDITION
    const deck = PERSISTENT_DECKS[deckIndex];
    const card = deck.find(c => c.id === cardId);
    
    if (card) {
      DOM.editModalTitle.textContent = 'Modifier la carte existante';
      DOM.editCardId.value = cardId;
      DOM.editCardDeckIndex.value = deckIndex;
      DOM.editCardText.value = card.text;
      DOM.editCardImg.value = card.img;
      DOM.editCardSoluceLink.value = card.soluceLink || '';
      DOM.editCardCorrect.value = card.correct;
      DOM.editDeckSelect.value = deckIndex.toString();
      DOM.editDeckSelect.disabled = true; // Emp√™che de changer le deck
      DOM.btnDeleteCard.style.display = 'block';
    }
  }
  openModal(DOM.editCardModal);
}

function saveCard() {
  const id = DOM.editCardId.value || crypto.randomUUID();
  const deckIndex = parseInt(DOM.editDeckSelect.value);
  const text = DOM.editCardText.value;
  const img = DOM.editCardImg.value;
  const soluceLink = DOM.editCardSoluceLink.value.trim();
  const correct = DOM.editCardCorrect.value;

  const newCard = { id, text, img, correct, soluceLink };
  
  let decks = loadDecks(); // Charge la version la plus r√©cente
  
  if (state.editingCardGlobalId) {
    // MODIFICATION
    const oldDeckIndex = parseInt(DOM.editCardDeckIndex.value);
    const cardIndex = decks[oldDeckIndex].findIndex(c => c.id === state.editingCardGlobalId);
    if (cardIndex !== -1) {
      decks[oldDeckIndex][cardIndex] = newCard;
    }
  } else {
    // AJOUT
    if (!decks[deckIndex]) decks[deckIndex] = []; // Cr√©e le deck s'il n'existe pas
    decks[deckIndex].push(newCard);
  }

  saveDecks(decks);
  PERSISTENT_DECKS = decks; // Met √† jour l'√©tat global
  closeModal(DOM.editCardModal);
  
  regenerateAllDynamicContent();
  showAllSoluce(); // Reste sur la page Admin
}

function deleteCard() {
  const cardId = DOM.editCardId.value;
  const deckIndex = parseInt(DOM.editCardDeckIndex.value);
  
  if (!cardId || isNaN(deckIndex)) return;
  
  // REMPLACEMENT: confirm -> showConfirm (logique asynchrone)
  
  // √âtape 1: D√©finir ce qu'il faut faire en cas de confirmation
  const onConfirmDelete = () => {
    let decks = loadDecks();
    decks[deckIndex] = decks[deckIndex].filter(card => card.id !== cardId);
    
    saveDecks(decks);
    PERSISTENT_DECKS = decks; // Met √† jour l'√©tat global
    closeModal(DOM.editCardModal);
    
    regenerateAllDynamicContent();
    showAllSoluce(); // Reste sur la page Admin
  };

  // √âtape 2: Afficher la modale de confirmation
  showConfirm(
    "Supprimer la carte",
    "√ätes-vous s√ªr de vouloir supprimer cette carte ? Cette action est irr√©versible.",
    onConfirmDelete
  );
}

function openDeckModal(deckIndex = null) {
  DOM.deckColorSelector.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
  DOM.editDeckId.value = '';

  if (deckIndex === null) {
    // MODE AJOUT
    DOM.deckModalTitle.textContent = "Cr√©er un nouveau Deck";
    DOM.deckNameInput.value = '';
    DOM.deckEmojiInput.value = '';
    DOM.deckIndicatorLeftInput.value = 'GAUCHE';
    DOM.deckIndicatorRightInput.value = 'DROITE';
    DOM.deckColorSelector.querySelector('.color-swatch').classList.add('selected');
  } else {
    // MODE √âDITION
    DOM.deckModalTitle.textContent = "Modifier le Deck";
    const deckInfo = PERSISTENT_DECK_INFO[deckIndex];
    DOM.editDeckId.value = deckIndex;
    DOM.deckNameInput.value = deckInfo.name;
    DOM.deckEmojiInput.value = deckInfo.emoji;
    DOM.deckIndicatorLeftInput.value = deckInfo.indicatorLeft || 'GAUCHE';
    DOM.deckIndicatorRightInput.value = deckInfo.indicatorRight || 'DROITE';
    
    const swatch = DOM.deckColorSelector.querySelector(`[data-color-name="${deckInfo.color}"]`);
    if (swatch) {
      swatch.classList.add('selected');
    } else {
      DOM.deckColorSelector.querySelector('.color-swatch').classList.add('selected'); // Fallback
    }
  }
  openModal(DOM.deckModal);
  DOM.deckNameInput.focus();
}

function saveDeckInfo() {
  const name = DOM.deckNameInput.value.trim();
  const emoji = DOM.deckEmojiInput.value.trim();
  const indicatorLeft = DOM.deckIndicatorLeftInput.value.trim();
  const indicatorRight = DOM.deckIndicatorRightInput.value.trim();
  const selectedColorEl = DOM.deckColorSelector.querySelector('.color-swatch.selected');
  const colorName = selectedColorEl ? selectedColorEl.getAttribute('data-color-name') : 'gray';

  if (!name || !emoji || !indicatorLeft || !indicatorRight) {
    // REMPLACEMENT: alert -> showAlert
    showAlert("Formulaire incomplet", "Veuillez remplir tous les champs.", "warning");
    return;
  }

  let decks = loadDecks();
  let info = loadDeckInfo();
  const colorClasses = getColorClasses(colorName);
  
  const newDeckInfo = {
    name: name,
    emoji: emoji,
    indicatorLeft: indicatorLeft,
    indicatorRight: indicatorRight,
    color: colorName,
    ...colorClasses
  };

  const deckIndexToEdit = DOM.editDeckId.value;

  if (deckIndexToEdit !== "") {
    // MODE √âDITION
    info[parseInt(deckIndexToEdit)] = newDeckInfo;
  } else {
    // MODE AJOUT
    info.push(newDeckInfo);
    decks.push([]); // Ajoute un tableau vide pour les cartes
  }

  saveDeckInfoToStorage(info);
  saveDecks(decks);
  
  PERSISTENT_DECKS = decks;
  PERSISTENT_DECK_INFO = info;
  
  regenerateAllDynamicContent();
  closeModal(DOM.deckModal);
  showAllSoluce(); // Reste sur la page Admin
}

// ------------------------------------
// --- FONCTIONS UTILITAIRES & UI ---
// ------------------------------------

function updateUI() {
  DOM.scoreDisplay.textContent = state.game.score;
  const cardNum = Math.min(state.game.cardIndex + 1, MAX_CARDS);
  DOM.indexDisplay.textContent = `${cardNum}/${MAX_CARDS}`;
  
  const finished = state.game.cardIndex >= MAX_CARDS;
  
  // CORRECTION: Cache la carte et les fl√®ches √† la fin du jeu
  DOM.cardHolder.classList.toggle('hidden', finished);
  DOM.arrowBtnContainer.classList.toggle('hidden', finished);
  
  // Affiche ou cache l'√©cran de fin
  DOM.endOverlay.classList.toggle('hidden', !finished);
}

function displayCard() {
  if (state.game.cardIndex < MAX_CARDS) {
    const cur = PERSISTENT_DECKS[state.currentDeck].find(c => c.id === state.currentDeckCards[state.game.cardIndex].id);
    
    if (cur) { // V√©rifie si la carte a √©t√© trouv√©e
      DOM.cardImage.src = cur.img;
      DOM.cardText.textContent = cur.text;
    } else {
      // Fallback si la carte a √©t√© supprim√©e pendant le jeu
      DOM.cardImage.src = neutralImg;
      DOM.cardText.textContent = "Erreur - Carte non trouv√©e";
    }
    
    DOM.cardElement.style.transform = 'none';
    DOM.cardElement.style.opacity = '1';
    DOM.cardElement.classList.remove('slide-out-left', 'slide-out-right');
    
    DOM.cardElement.style.borderColor = 'rgba(255,255,255,0.04)'; 
    DOM.overlayLeft.style.opacity = '0';
    DOM.overlayRight.style.opacity = '0';
    
    const deckInfo = PERSISTENT_DECK_INFO[state.currentDeck];
    DOM.indicatorLeft.innerHTML = deckInfo.indicatorLeft || 'GAUCHE';
    DOM.indicatorRight.innerHTML = deckInfo.indicatorRight || 'DROITE';
    
    DOM.indicatorLeft.style.opacity = '0';
    DOM.indicatorRight.style.opacity = '0';
    DOM.indicatorLeft.style.transform = 'translateY(-50%) translateX(0px)';
    DOM.indicatorRight.style.transform = 'translateY(-50%) translateX(0px)';
  } else {
    endGame();
  }
}

function updateVisualFeedback(dx) {
  const opacityRatio = Math.min(1, Math.abs(dx) / 100); 

  if (dx < 0) { // Glissement vers la gauche
    DOM.overlayLeft.style.opacity = (opacityRatio * 0.9).toString();
    DOM.overlayRight.style.opacity = '0';
    DOM.indicatorLeft.style.opacity = opacityRatio > 0.1 ? '1' : '0';
    DOM.indicatorRight.style.opacity = '0';
    DOM.indicatorLeft.style.transform = `translateY(-50%) translateX(${Math.min(0, 10 + dx / 5)}px)`;
  } else if (dx > 0) { // Glissement vers la droite
    DOM.overlayRight.style.opacity = (opacityRatio * 0.9).toString();
    DOM.overlayLeft.style.opacity = '0';
    DOM.indicatorRight.style.opacity = opacityRatio > 0.1 ? '1' : '0';
    DOM.indicatorLeft.style.opacity = '0';
    DOM.indicatorRight.style.transform = `translateY(-50%) translateX(${Math.max(0, dx / 5 - 10)}px)`;
  } else {
    DOM.overlayLeft.style.opacity = '0';
    DOM.overlayRight.style.opacity = '0';
    DOM.indicatorLeft.style.opacity = '0';
    DOM.indicatorRight.style.opacity = '0';
    DOM.indicatorLeft.style.transform = 'translateY(-50%) translateX(0px)';
    DOM.indicatorRight.style.transform = 'translateY(-50%) translateX(0px)';
  }
}

function displayErrorRecap() {
  DOM.recapList.innerHTML = '';
  
  if (state.resultsRecap.length === 0) {
    DOM.recapTitle.textContent = "Aucune carte jou√©e dans cette partie.";
    return;
  }

  DOM.recapTitle.textContent = "R√©sultat de la partie";

  state.resultsRecap.forEach((playedCard) => {
    const card = PERSISTENT_DECKS[state.currentDeck].find(c => c.id === playedCard.id);
    if (!card) return; // Ignore si la carte n'existe plus
    
    const status = playedCard.isCorrect ? 'success' : 'error';
    const statusText = playedCard.isCorrect ? 'R√âUSSIE' : 'ERREUR';
    
    const el = document.createElement('div');
    el.className = `result-vignette ${status} flex flex-col items-center justify-between`;
    
    const hasSoluceLink = card.soluceLink && card.soluceLink.trim() !== "";
    
    // CORRECTION: Ajout du curseur et du listener pour tous les cas
    el.style.cursor = 'pointer';
    el.addEventListener('click', () => {
      if (hasSoluceLink) {
        window.open(card.soluceLink, '_blank');
      } else {
        openModal(card.img); // Ajout du zoom
      }
    });

    el.innerHTML = `
      <img src="${card.img}" alt="${statusText}" onerror="this.onerror=null;this.src='https://placehold.co/100x60/${status === 'success' ? '10B981' : 'EF4444'}/FFFFFF?text=${statusText}';" />
      <div class="text-[0.6rem] text-gray-300 truncate w-full mt-0.5">${card.text.split(' (')[0] || "Carte"}</div>
    `;
    DOM.recapList.appendChild(el);
  });
}

function renderScores() {
  const allScores = getScores();
  const filtered = state.currentFilter === 'all' ? allScores : allScores.filter(s => s.deck === state.currentFilter);
  
  DOM.scoresList.innerHTML = '';
  if (filtered.length === 0) {
    DOM.scoresList.innerHTML = '<div class="text-gray-300 text-center py-6">Aucun score enregistr√©.</div>';
    return;
  }
  
  filtered.forEach(score => {
    const el = document.createElement('div');
    el.className = 'flex justify-between items-center p-3 bg-white/5 rounded-lg hover:bg-white/8 transition';
    const deckInfo = PERSISTENT_DECK_INFO[score.deck];
    const deckEmoji = score.deckEmoji || (deckInfo ? deckInfo.emoji : '‚ùì');
    // S√©curisation du nom du joueur
    const safePlayerName = (score.player || "Sans nom").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    
    el.innerHTML = `
      <div>
        <div class="flex items-center gap-2 mb-1">
          <span class="text-xl">${deckEmoji}</span>
          <span class="font-semibold">${safePlayerName}</span>
        </div>
        <div class="text-xs text-gray-400">${new Date(score.timestamp).toLocaleString('fr-FR')}</div>
      </div>
      <div class="text-right">
        <div class="text-2xl font-bold ${score.percentage === 0 ? 'text-green-400' : score.percentage === 100 ? 'text-pink-400' : 'text-purple-400'}">${score.percentage}%</div>
        <div class="text-xs text-gray-400">${score.errors} erreur${score.errors > 1 ? 's' : ''}</div>
      </div>
    `;
    DOM.scoresList.appendChild(el);
  });
}

function filterScores(filter, targetElement) {
  state.currentFilter = filter;
  DOM.scoreFilterButtons.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
  targetElement.classList.add('active'); 
  renderScores();
}

function saveScore(playerName, deckIndex, errors, percentage) {
  const scores = getScores();
  const deckInfo = PERSISTENT_DECK_INFO[deckIndex];
  scores.unshift({
    player: playerName,
    deck: deckIndex,
    deckName: deckInfo ? deckInfo.name : "Deck Inconnu",
    deckEmoji: deckInfo ? deckInfo.emoji : "‚ùì",
    errors: errors,
    percentage: percentage,
    timestamp: Date.now()
  });
  localStorage.setItem('game_scores', JSON.stringify(scores.slice(0, 100)));
}

// --- Fonctions Modales ---
function openModal(modalEl) {
  if (typeof modalEl === 'string') {
    // C'est une URL d'image pour l'imageModal
    DOM.modalImage.src = modalEl;
    DOM.imageModal.classList.add('active');
  } else {
    // C'est un √©l√©ment modal
    modalEl.classList.add('active');
  }
}

function closeModal(modalEl) {
  modalEl.classList.remove('active');
}

function openPasswordModal() {
  DOM.passwordInput.value = '';
  DOM.passwordError.classList.add('hidden');
  openModal(DOM.passwordModal);
  DOM.passwordInput.focus();
}

function isModalOpen() {
  return DOM.imageModal.classList.contains('active') || 
         DOM.passwordModal.classList.contains('active') || 
         DOM.editCardModal.classList.contains('active') ||
         DOM.deckModal.classList.contains('active') ||
         DOM.alertModal.classList.contains('active'); // AJOUT
}

// ------------------------------------
// --- NOUVELLES FONCTIONS D'ALERTE ---
// ------------------------------------

/**
 * Affiche une alerte non bloquante.
 * @param {string} title - Le titre de l'alerte.
 * @param {string} text - Le message de l'alerte.
 * @param {string} type - 'info' (d√©faut), 'success' (vert), 'warning' (orange), 'error' (rouge).
 */
function showAlert(title, text, type = 'info') {
  DOM.alertModalTitle.textContent = title;
  DOM.alertModalText.textContent = text;
  DOM.alertModalButtons.innerHTML = ''; // Vide les anciens boutons

  // Couleur du titre
  DOM.alertModalTitle.className = "text-2xl font-bold mb-4 ";
  switch (type) {
    case 'success':
      DOM.alertModalTitle.classList.add('text-green-400');
      break;
    case 'error':
      DOM.alertModalTitle.classList.add('text-red-400');
      break;
    case 'warning':
      DOM.alertModalTitle.classList.add('text-yellow-400');
      break;
    default:
      DOM.alertModalTitle.classList.add('text-white');
  }

  // Bouton OK
  const okButton = document.createElement('button');
  okButton.textContent = "OK";
  okButton.className = "px-6 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg font-semibold";
  okButton.onclick = () => closeModal(DOM.alertModal);
  
  DOM.alertModalButtons.appendChild(okButton);
  openModal(DOM.alertModal);
}

/**
 * Affiche une confirmation non bloquante.
 * @param {string} title - Le titre de la confirmation.
 * @param {string} text - La question de confirmation.
 * @param {function} onConfirm - La fonction callback √† ex√©cuter si l'utilisateur confirme.
 */
function showConfirm(title, text, onConfirm) {
  DOM.alertModalTitle.textContent = title;
  DOM.alertModalText.textContent = text;
  DOM.alertModalButtons.innerHTML = ''; // Vide les anciens boutons
  DOM.alertModalTitle.className = "text-2xl font-bold mb-4 text-white"; // Couleur par d√©faut

  // Bouton Annuler
  const cancelButton = document.createElement('button');
  cancelButton.textContent = "Annuler";
  cancelButton.className = "px-6 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg font-semibold";
  cancelButton.onclick = () => closeModal(DOM.alertModal);
  
  // Bouton Confirmer (rouge pour indiquer une action destructive)
  const confirmButton = document.createElement('button');
  confirmButton.textContent = "Confirmer";
  confirmButton.className = "px-6 py-2 bg-red-600 hover:bg-red-700 rounded-lg font-semibold";
  confirmButton.onclick = () => {
    closeModal(DOM.alertModal);
    onConfirm(); // Ex√©cute le callback
  };
  
  DOM.alertModalButtons.appendChild(cancelButton);
  DOM.alertModalButtons.appendChild(confirmButton);
  openModal(DOM.alertModal);
}

// --- Autres Utilitaires ---
function shuffleArray(array) {
  const newArray = [...array]; 
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
}

function getResultMessage(errorPercent) {
  const deckIndex = state.currentDeck;
  const deckMessages = [
    // Deck 0: Classic
    {
      0: { text: "PERFECT! ZERO ERREUR", color: "bg-green-600" },
      100: { text: "100% GAY", color: "bg-pink-600" },
      50: { text: "UN TROU C UN TROU", color: "bg-purple-600" },
      default: { text: "PETIT CURIEUX", color: "bg-blue-600" }
    },
    // Deck 1: Hardcore
    {
      0: { text: "Intello du PC!", color: "bg-green-600" },
      100: { text: "100% Consoleux", color: "bg-red-600" },
      50: { text: "Gamer du dimanche", color: "bg-yellow-600" },
      default: { text: "Connaisseur", color: "bg-blue-600" }
    },
    // Deck 2: Cosplay
    {
      0: { text: "Ma√Ætre du d√©guisement", color: "bg-green-600" },
      100: { text: "A besoin d'une-up", color: "bg-red-600" },
      50: { text: "Encore en civil", color: "bg-yellow-600" },
      default: { text: "Passionn√© de Pop Culture", color: "bg-blue-600" }
    }
  ];
  
  const messages = deckMessages[deckIndex] || {
    // Fallback pour les nouveaux decks
    0: { text: "PARFAIT !", color: "bg-green-600" },
    50: { text: "Peut mieux faire", color: "bg-yellow-600" },
    default: { text: "Bien jou√© !", color: "bg-blue-600" }
  };

  if (errorPercent === 0) return messages[0];
  if (errorPercent === 100 && messages[100]) return messages[100];
  if (errorPercent >= 50 && messages[50]) return messages[50];
  return messages.default;
}

function getColorClasses(colorName) {
  const colorMap = {
    "purple": { titleColor: "text-purple-400", cardBorder: "border-purple-400/30" },
    "cyan": { titleColor: "text-cyan-400", cardBorder: "border-cyan-400/30" },
    "pink": { titleColor: "text-pink-400", cardBorder: "border-pink-400/30" },
    "green": { titleColor: "text-green-400", cardBorder: "border-green-400/30" },
    "yellow": { titleColor: "text-yellow-400", cardBorder: "border-yellow-400/30" },
    "gray": { titleColor: "text-gray-400", cardBorder: "border-gray-400/30" },
    "red": { titleColor: "text-red-400", cardBorder: "border-red-400/30" },
    "blue": { titleColor: "text-blue-400", cardBorder: "border-blue-400/30" },
    "indigo": { titleColor: "text-indigo-400", cardBorder: "border-indigo-400/30" },
    "emerald": { titleColor: "text-emerald-400", cardBorder: "border-emerald-400/30" },
    "orange": { titleColor: "text-orange-400", cardBorder: "border-orange-400/30" }
  };
  return colorMap[colorName] || colorMap["gray"];
}
