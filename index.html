<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jeu de Tri de Cartes ‚Äì Version Finale Compl√®te</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* STYLES CSS COMPLETS (Base + Ajouts pour le feedback dynamique) */
    .bg-game { background: linear-gradient(180deg,#0b1220 0%, #071018 100%); }
    .glass { background: rgba(255,255,255,0.03); backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,0.04); }
    /* MODIF CSS: Ajout de 'border-color' pour le feedback vert/rouge */
    .card-container { transition: transform .35s cubic-bezier(.22,.9,.27,1), opacity .35s, border-color .3s; will-change: transform, opacity, border-color; touch-action: none; cursor: grab; }
    .slide-out-left { transform: translateX(-150vw) rotate(-22deg) !important; opacity: 0; }
    .slide-out-right { transform: translateX(150vw) rotate(22deg) !important; opacity: 0; }
    .screen { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; }
    .hidden-screen{ display:none; }
    .circular-gauge { width: 200px; height: 200px; position: relative; }
    .circular-gauge svg { transform: rotate(-90deg); }
    .gauge-bg { fill: none; stroke: rgba(255,255,255,0.1); stroke-width: 20; }
    .gauge-progress { fill: none; stroke: url(#gaugeGradient); stroke-width: 20; stroke-linecap: round; transition: stroke-dashoffset 1.5s cubic-bezier(0.4, 0, 0.2, 1); }
    .gauge-center { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
    .deck-card { transition: all 0.3s ease; cursor: pointer; }
    .deck-card:hover { transform: translateY(-8px); box-shadow: 0 20px 40px rgba(0,0,0,0.4); }
    .filter-btn { transition: all 0.2s ease; }
    .filter-btn.active { background: rgba(99, 102, 241, 0.5); border-color: rgb(99, 102, 241); }
    .pop{ animation: popInUp .36s cubic-bezier(.2,.9,.3,1) both; }
    @keyframes popInUp{ from{ transform: translateY(18px) scale(.99); opacity:0 } to{ transform: translateY(0) scale(1); opacity:1 } }
    input[type="text"].player-input{ background:#f3f4f6; color:#0f172a; }
    .msg { transition: opacity .25s ease; }
    .result-message { animation: fadeInScale 0.6s cubic-bezier(0.2, 0.9, 0.3, 1) 0.3s both; }
    @keyframes fadeInScale { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
    /* AJOUTS CSS POUR LE FEEDBACK DYNAMIQUE */
    .overlay-gradient { 
        position: absolute; 
        top: 0; 
        bottom: 0; 
        width: 50%; 
        opacity: 0; 
        pointer-events: none;
        transition: opacity .1s linear;
    }
    #overlay-left { left: 0; background: linear-gradient(90deg, rgba(168,85,247, 0.1) 0%, rgba(168,85,247, 0) 100%); }
    #overlay-right { right: 0; background: linear-gradient(-90deg, rgba(236,72,153, 0.1) 0%, rgba(236,72,153, 0) 100%); }
    .swipe-indicator {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        font-size: 1.5rem;
        font-weight: bold;
        padding: 0.5rem 1rem;
        border-radius: 9999px;
        z-index: 50;
        opacity: 0;
        transition: opacity .1s linear, transform .1s linear;
    }
    #indicator-left { left: -1rem; color: #c084fc; background: rgba(168,85,247, 0.2); }
    #indicator-right { right: -1rem; color: #f472b6; background: rgba(236,72,153, 0.2); }

    /* NOUVEAU STYLE POUR LE R√âCAPITULATIF */
    .error-card-recap { transition: transform 0.3s ease; cursor: pointer; }
    .error-card-recap:hover { transform: translateY(-3px); }

    /* STYLE DE LA MODALE ET MODALE MOT DE PASSE */
    .base-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.95);
        display: none; 
        z-index: 9999;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    .base-modal.active {
        display: flex;
        opacity: 1;
    }
    #modal-content, #password-modal-content, #edit-modal-content, #deck-modal-content {
        max-width: 90%;
        padding: 1.5rem;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 1.5rem;
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.6);
        max-height: 90%;
        box-sizing: border-box;
        /* CORRECTION: Ajout de flex pour le scrolling interne */
        display: flex;
        flex-direction: column;
    }
    #modal-image {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        border-radius: 1rem;
    }
    .close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        font-size: 2rem;
        cursor: pointer;
        color: white;
        text-shadow: 0 0 10px black;
        transition: color 0.2s;
    }
    .close-btn:hover {
        color: #ec4899;
    }
    #password-input {
        letter-spacing: 0.5rem;
        text-align: center;
        font-size: 1.5rem;
    }
    
    /* STYLES DE BOUTONS FL√àCHES */
    .arrow-btn-container {
      margin-top: 1.5rem;
      width: 100%;
      max-width: 320px;
    }
    .arrow-btn {
        width: 70px;
        height: 48px;
        border-radius: 9999px; /* Pill shape */
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        font-weight: bold;
        transition: background-color 0.2s, transform 0.2s;
        cursor: pointer;
        border: 2px solid;
    }
    .arrow-btn:hover {
        transform: scale(1.05);
    }
    #btn-arrow-left {
        background-color: rgba(168, 85, 247, 0.2);
        border-color: #a855f7;
        color: #a855f7;
    }
    #btn-arrow-right {
        background-color: rgba(236, 72, 153, 0.2);
        border-color: #ec4899;
        color: #ec4899;
    }
    .arrow-svg {
        width: 24px; /* Taille du SVG */
        height: 24px;
        fill: currentColor; /* Le SVG prend la couleur du parent */
        stroke-width: 2;
    }
    /* STYLE POUR LE PETIT BOUTON SOLUCE SUR DECK SCREEN */
    #btn-view-soluce-deck {
        transition: transform 0.2s ease;
    }
    #btn-view-soluce-deck:hover {
        transform: scale(1.05);
    }

    /* Style pour la galerie Soluce */
    .soluce-gallery-item {
        width: 120px;
        height: 160px;
        transition: transform 0.3s ease;
        object-fit: cover;
        position: relative;
        padding: 0.5rem;
        cursor: default;
    }
    .soluce-gallery-item-image-container {
        position: relative;
        /* CURSEUR EN MODE CONSULTATION D√âSACTIV√â */
        cursor: default; 
    }
    /* Style pour le curseur en mode √©dition/soluce */
    /* MODIFICATION: SOLUCE LINK MODE UTILISE MAINTENANT isEditingMode UNIQUEMENT POUR LE CURSEUR */
    .soluce-gallery-item.editing-mode {
        cursor: pointer !important;
        outline: 2px dashed #34d399; /* Vert pour √©dition */
    }
    .soluce-gallery-item.editing-mode:hover {
        transform: scale(1.02);
    }
    
    /* MODIFICATION: Le mode de base (lien/zoom) utilise le curseur par d√©faut, mais ajoute le lien/agrandir au clic */
    .soluce-gallery-item {
        cursor: pointer;
    }
    
    /* Suppression de l'indication "cliquez pour agrandir" */
    .edit-overlay-consult { display: none !important; }

    /* Style pour les s√©parateurs de Deck dans Soluce */
    .soluce-deck-title {
        width: 100%;
        text-align: center;
        padding: 0.5rem 0;
        margin-top: 1.5rem;
        margin-bottom: 0.5rem;
        font-size: 1.5rem;
        font-weight: bold;
        border-bottom: 2px solid rgba(255, 255, 255, 0.1); 
        /* Ajout pour l'√©dition de deck */
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
    }
    .edit-deck-btn {
        font-size: 1rem;
        cursor: pointer;
        display: none; /* Cach√© par d√©faut */
        transition: transform 0.2s;
    }
    .edit-deck-btn:hover {
        transform: scale(1.2);
    }

    /* Styles pour cacher/montrer les decks de solution */
    .soluce-deck-content.hidden-soluce {
        display: none;
    }
    .soluce-deck-content {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 1rem; /* Espace entre les vignettes */
    }
    /* Champs d'√©dition */
    #edit-card-modal input, #edit-card-modal select, #deck-modal-content input, #deck-modal-content select {
        width: 100%;
        padding: 0.5rem;
        border-radius: 0.5rem;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        margin-bottom: 0.75rem;
    }
    #edit-card-modal label, #deck-modal-content label {
        font-size: 0.875rem;
        color: #94a3b8;
        display: block;
        margin-bottom: 0.25rem;
        text-align: left;
    }
    /* Indicateur de lien soluce */
    .soluce-link-indicator {
        position: absolute;
        top: 5px;
        right: 5px;
        color: #f472b6;
        font-size: 1.25rem;
        pointer-events: none; /* Ne doit pas bloquer le clic sur la vignette */
    }
    /* Nouveau style pour les vignettes de r√©sultats */
    .result-vignette {
        border-radius: 0.5rem;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        padding: 0.5rem;
        text-align: center;
        max-width: 100px;
        min-width: 80px;
        margin: 0.25rem;
    }
    .result-vignette.success {
        border: 2px solid #10B981; /* Vert */
    }
    .result-vignette.error {
        border: 2px solid #EF4444; /* Rouge */
    }
    .result-vignette img {
        width: 100%;
        height: 60px;
        object-fit: cover;
        border-radius: 0.25rem;
        margin-bottom: 0.25rem;
    }
    .result-vignette .result-status {
        font-size: 0.7rem;
        font-weight: bold;
        text-transform: uppercase;
    }
    .result-vignette.success .result-status {
        color: #10B981;
    }
    .result-vignette.error .result-status {
        color: #EF4444;
    }
    /* Style du bouton zoom sur la carte de jeu (SUPPRIM√â) */
    /*
    #btn-zoom-card { ... }
    */
    /* Style pour le petit bouton admin dans le header */
    .header-admin-btn {
        padding: 0.25rem 0.5rem;
        border-radius: 0.5rem;
        font-size: 0.75rem;
        font-weight: bold;
        transition: background-color 0.2s;
        cursor: pointer;
        position: absolute;
        left: 1.5rem; /* Laisser un peu de marge */
        top: 50%;
        transform: translateY(-50%);
        z-index: 10;
    }

    /* NOUVEAU STYLE: Bouton "Ajouter" (+) */
    .add-card-btn {
        width: 120px;
        height: 160px;
        display: none; /* Cach√© par d√©faut */
        align-items: center;
        justify-content: center;
        border: 2px dashed rgba(255, 255, 255, 0.3);
        border-radius: 0.5rem;
        cursor: pointer;
        transition: all 0.2s ease;
        padding: 0.5rem; /* Correspond √† .soluce-gallery-item */
    }
    .add-card-btn:hover {
        border-color: #34d399; /* Teal */
        background: rgba(52, 211, 153, 0.1);
    }
    .add-card-btn svg {
        width: 40px;
        height: 40px;
        stroke: rgba(255, 255, 255, 0.4);
        transition: all 0.2s ease;
    }
    .add-card-btn:hover svg {
        stroke: #34d399;
        transform: scale(1.1);
    }
    
    /* NOUVEAU STYLE: S√©lecteur de couleur pour Deck */
    .color-swatch {
        width: 2rem;
        height: 2rem;
        border-radius: 50%;
        cursor: pointer;
        border: 3px solid transparent;
        transition: transform 0.2s, border-color 0.2s;
    }
    .color-swatch.selected {
        border-color: #ffffff;
        transform: scale(1.1);
    }
    .color-swatch:hover {
        transform: scale(1.1);
    }
  </style>
</head>
<body class="bg-game text-white min-h-screen font-sans flex items-center justify-center p-6">
  <div id="app" class="relative w-full max-w-3xl">
    <!-- MODIFICATION: Ajout du bouton Admin dans le header -->
    <header class="flex items-center justify-between mb-6 relative">
      <!-- CORRECTION: Ajout de onclick="openPasswordModal()" -->
      <button id="btn-header-admin" class="header-admin-btn bg-pink-600/60 border border-pink-500 text-white" onclick="openPasswordModal()">Admin</button>
      <!-- MODIFICATION: Ajout de flex-1 et text-center pour centrer le titre -->
      <h1 class="text-2xl font-extrabold flex-1 text-center">TORG_BETA v1</h1>
      <div class="text-sm text-gray-300">Joueur: <span id="player-display">N/A</span></div>
    </header>

    <main class="relative w-full h-[680px] rounded-2xl overflow-hidden border border-white/6 shadow-2xl">

      <section id="intro-screen" class="screen glass p-8 z-40">
        <div class="w-full max-w-md text-center mx-auto">
          <h2 class="text-3xl font-bold mb-2">Bienvenue</h2>
          <p class="text-sm text-gray-300 mb-4">Entre ton pseudo pour commencer √† jouer.</p>
          <input id="player-name" class="player-input w-full p-3 rounded-lg placeholder-gray-500 border border-gray-300 mb-4" type="text" maxlength="24" placeholder="Ton pseudo" />
          <div class="flex gap-3 justify-center">
            <button id="btn-start" class="px-6 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg font-semibold">Continuer</button>
            <button id="btn-view-scores" class="px-4 py-2 bg-white/6 hover:bg-white/8 rounded-lg">Scores</button>
          </div>
          <p class="text-xs text-gray-400 mt-4">Astuce : swipe vers la gauche/droite ou utilise les fl√®ches ‚Üê ‚Üí</p>
        </div>
      </section>

      <section id="deck-screen" class="screen hidden-screen glass p-8 z-35">
        <div class="w-full max-w-4xl mx-auto">
          <h2 class="text-3xl font-bold mb-2 text-center">Choisis ton Deck</h2>
          <p class="text-sm text-gray-300 mb-8 text-center">S√©lectionne un deck pour commencer la partie</p>
          
          <!-- MODIFICATION: Remplacement du contenu statique par un conteneur dynamique -->
          <div id="deck-selection-grid" class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <!-- Les cartes de deck seront g√©n√©r√©es ici par JS -->
          </div>

          <div class="mt-6 text-center flex justify-center gap-3">
            <button id="btn-view-scores-from-deck" class="px-4 py-2 bg-white/6 hover:bg-white/8 rounded-lg text-sm">Scores</button>
            <!-- NOUVEAU BOUTON GALERIE SOLUCE (publique) -->
            <button id="btn-view-public-soluce" class="px-4 py-2 bg-indigo-600/60 border border-indigo-500 rounded-lg text-sm" onclick="showPublicSoluce()">Galerie Soluce</button> 
            <!-- NOUVEAU BOUTON : CHANGER PSEUDO -->
            <button id="btn-change-player" class="px-4 py-2 bg-white/6 hover:bg-white/8 rounded-lg text-sm" onclick="showScreen(introScreen)">Changer Pseudo</button>
          </div>
        </div>
      </section>

      <section id="game-screen" class="screen hidden-screen p-6 z-30 flex-col">
        
        <div id="overlay-left" class="overlay-gradient"></div>
        <div id="overlay-right" class="overlay-gradient"></div>
        <div class="flex justify-between w-full mb-4 items-center px-6">
          <div class="flex items-center gap-4">
              <div class="text-lg">Score: <span id="score-display">0</span></div>
              <div class="text-lg">Carte: <span id="index-display">1/10</span></div>
          </div>
          <button id="btn-quit-game" class="px-3 py-1 bg-white/10 hover:bg-white/20 text-sm rounded-lg" onclick="quitGame()">Quitter</button>
        </div>

        <div id="card-holder" class="relative w-full max-w-lg mx-auto h-[520px] flex items-center justify-center px-6">
          
          <div id="indicator-left" class="swipe-indicator">TRANS</div>
          <div id="indicator-right" class="swipe-indicator">GIRL</div>

          <!-- LA CARTE DE JEU (clic pour agrandir r√©activ√©) -->
          <div id="card" class="card-container relative w-full h-full bg-gradient-to-b from-gray-800/85 to-gray-900/70 rounded-2xl shadow-2xl p-6 flex flex-col justify-between items-center border border-white/6" onclick="openModal(cardImage.src)">
            <img id="card-image" src="" alt="Carte" class="w-full h-auto max-h-[72%] object-contain rounded-lg shadow-inner mt-4" onerror="this.onerror=null;this.src='https://placehold.co/400x550/2563EB/FFFFFF?text=Carte';" />
            
            <!-- BOUTON ZOOM SUPPRIM√â -->

            <p id="card-text" class="text-lg text-center font-medium text-gray-100 mt-4 mb-2"></p>
          </div>

          <div id="end-overlay" class="absolute inset-0 flex-col justify-center items-center text-center hidden z-40 glass p-6 overflow-y-auto">
            <h2 class="text-4xl font-extrabold text-teal-300 mb-6 pop">Fin de Partie</h2>
            
            <div class="circular-gauge mx-auto mb-6">
              <svg viewBox="0 0 200 200" width="200" height="200">
                <defs>
                  <linearGradient id="gaugeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#06b6d4" />
                    <stop offset="50%" stop-color="#7c3aed" />
                    <stop offset="100%" stop-color="#ec4899" />
                  </linearGradient>
                </defs>
                <circle class="gauge-bg" cx="100" cy="100" r="80" />
                <circle id="gauge-circle" class="gauge-progress" cx="100" cy="100" r="80" 
                        stroke-dasharray="502.65" stroke-dashoffset="502.65" />
              </svg>
              <div class="gauge-center">
                <div class="text-5xl font-black text-white" id="gauge-percentage">0%</div>
                <div class="text-xs text-gray-400 mt-1">d'erreurs</div>
              </div>
            </div>

            <!-- MODIFICATION: Ajout du "Vous √™tes :" -->
            <p class="text-lg text-gray-300 mb-2">Vous √™tes :</p>
            <div id="result-message" class="result-message text-2xl font-bold mb-4 px-4 py-3 rounded-lg"></div>

            <!-- MODIFICATION ICI: Titre et conteneur pour tous les r√©sultats -->
            <div id="error-recap" class="w-full mb-6 max-w-md mx-auto">
                <p id="recap-title" class="text-xl font-bold text-gray-100 mb-4">R√©sultat de la partie</p>
                <div id="recap-list" class="flex flex-wrap justify-center gap-2">
                    <!-- Les vignettes de r√©sultats seront ins√©r√©es ici -->
                </div>
            </div>

            <div class="flex gap-3 justify-center flex-wrap">
              <button id="btn-choose-deck" class="px-6 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg font-semibold">Choisir un autre Deck</button>
              <button id="btn-replay" class="px-4 py-2 bg-white/6 rounded-lg">Rejouer ce Deck</button>
              <button id="btn-view-scores-from-game" class="px-4 py-2 bg-white/6 rounded-lg">Voir Scores</button>
              <!-- BOUTON SOLUCE SUPPRIM√â D'ICI -->
            </div>
          </div>

        </div>

        <!-- BOUTONS DE D√âCISION (Fl√®ches SVG) -->
        <div class="flex justify-between items-center arrow-btn-container mx-auto">
            <button id="btn-arrow-left" class="arrow-btn" onclick="handleDecision('left')">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" class="arrow-svg">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18" />
                </svg>
            </button>
            <button id="btn-arrow-right" class="arrow-btn" onclick="handleDecision('right')">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" class="arrow-svg">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3" />
                </svg>
            </button>
        </div>

        <div id="message-box" class="mt-4 p-3 bg-yellow-900 text-yellow-300 rounded-lg text-center hidden msg">Message</div>
      </section>

      <section id="scores-screen" class="screen hidden-screen glass p-6 z-20 flex-col">
        <div class="w-full max-w-2xl mx-auto">
          <div class="flex justify-between items-center mb-4">
            <h3 class="text-2xl font-bold">Historique des Scores</h3>
            <button id="btn-back-from-scores" class="px-3 py-1 bg-indigo-600 rounded" onclick="showScreen(deckScreen)">Retour</button>
          </div>

          <div id="score-filter-buttons" class="flex gap-2 mb-4 flex-wrap">
            <button class="filter-btn active px-4 py-2 bg-white/6 border border-white/10 rounded-lg text-sm" onclick="filterScores('all', event)">Tous</button>
            <!-- Les filtres de deck seront g√©n√©r√©s dynamiquement -->
          </div>

          <div id="scores-list" class="space-y-2 max-h-[480px] overflow-auto p-3 bg-white/4 rounded-lg"></div>
        </div>
      </section>

      <!-- √âCRAN ADMINISTRATEUR (Anciennement Soluce Screen) -->
      <!-- MODIFICATION: Ajout de !items-start et overflow-y-auto -->
      <section id="soluce-screen" class="screen hidden-screen glass p-6 z-20 flex-col !items-start overflow-y-auto">
        <div class="w-full max-w-2xl mx-auto">
          <div class="flex justify-between items-center mb-4">
            <!-- TITRE ADMIN -->
            <h3 class="text-2xl font-bold">Admin</h3>
            <div class="flex gap-3">
                <!-- NOUVEAU BOUTON ACTIVER √âDITION -->
                <button id="btn-toggle-edit" class="px-3 py-1 bg-teal-600 hover:bg-teal-700 rounded" onclick="toggleEditingMode()">Activer l'√©dition</button>
                
                <!-- NOUVEAU BOUTON AJOUTER UN DECK (visible en mode √©dition) -->
                <button id="btn-add-deck" class="px-4 py-1 bg-green-600 hover:bg-green-700 rounded-lg font-semibold" style="display: none;">Cr√©er Deck</button>
                
                <!-- BOUTON RETOUR AU JEU -->
                <button id="btn-back-from-soluce-admin" class="px-3 py-1 bg-indigo-600 rounded" onclick="showScreen(deckScreen)">Retour au Jeu</button>
            </div>
          </div>

          <p class="text-sm text-gray-300 mb-4">Mode par d√©faut: Cliquez sur une vignette pour agrandir l'image. Utilisez les boutons ci-dessus pour changer de mode.</p>

          <!-- MODIFICATION: Suppression de max-h-[480px] overflow-y-auto -->
          <div id="soluce-gallery-container" class="p-3 bg-white/4 rounded-lg">
            <!-- Les 3 galeries de deck seront g√©n√©r√©es ici par JS lors de la premi√®re ex√©cution -->
          </div>
          
        </div>
      </section>
      <!-- FIN √âCRAN ADMINISTRATEUR -->

      <!-- NOUVEL √âCRAN DE SOLUTION (PUBLIC) -->
      <!-- MODIFICATION: Ajout de !items-start et overflow-y-auto -->
      <section id="public-soluce-screen" class="screen hidden-screen glass p-6 z-20 flex-col !items-start overflow-y-auto">
        <div class="w-full max-w-2xl mx-auto">
          <div class="flex justify-between items-center mb-4">
            <h3 class="text-2xl font-bold">Galerie Solution</h3>
            <button id="btn-back-from-public-soluce" class="px-3 py-1 bg-indigo-600 rounded" onclick="showScreen(deckScreen)">Retour au Jeu</button>
          </div>

          <p class="text-sm text-gray-300 mb-4">Cliquez sur une carte pour l'agrandir.</p>

          <!-- MODIFICATION: Suppression de max-h-[480px] overflow-y-auto -->
          <div id="public-soluce-gallery-container" class="p-3 bg-white/4 rounded-lg">
            <!-- Contenu g√©n√©r√© par generatePublicSoluceContainers() -->
          </div>
        </div>
      </section>
      <!-- FIN NOUVEL √âCRAN PUBLIC -->

    </main>
  </div>

  <!-- MODALE MOT DE PASSE -->
  <div id="password-modal" class="base-modal">
    <span class="close-btn" onclick="closePasswordModal()">&times;</span>
    <div id="password-modal-content" class="w-full max-w-xs text-center">
      <h4 class="text-xl font-bold mb-4">Mot de Passe Soluce</h4>
      <p class="text-sm text-gray-400 mb-4">Entrez le code √† 4 chiffres pour acc√©der √† la galerie.</p>
      <input type="password" id="password-input" maxlength="4" class="w-full p-3 mb-4 rounded-lg bg-gray-700 text-white border border-pink-500/50 focus:border-pink-500 focus:ring-0" />
      <button onclick="checkPassword()" class="w-full py-2 bg-pink-600 hover:bg-pink-700 rounded-lg font-semibold">D√©verrouiller</button>
      <p id="password-error" class="text-sm text-red-400 mt-3 hidden">Code incorrect. Veuillez r√©essayer.</p>
    </div>
  </div>

  <!-- MODALE D'√âDITION/AJOUT DE CARTE -->
  <div id="edit-card-modal" class="base-modal">
    <span class="close-btn" onclick="closeEditModal()">&times;</span>
    <div id="edit-modal-content" class="w-full max-w-lg text-center flex flex-col">
        <h4 id="edit-modal-title" class="text-2xl font-bold mb-4 flex-shrink-0">Ajouter une nouvelle carte</h4>
        
        <!-- CORRECTION: Formulaire mis dans un conteneur scrollable -->
        <form id="card-form" class="flex flex-col flex-grow min-h-0" onsubmit="return false;">
            <div class="flex-grow overflow-y-auto pr-2">
                <!-- Champ cach√© pour l'index de la carte (pour l'√©dition) -->
                <input type="hidden" id="edit-card-deck-index">
                <input type="hidden" id="edit-card-id">
                
                <label for="edit-deck-select">S√©lectionner le Deck :</label>
                <select id="edit-deck-select">
                    <!-- Les options de deck seront g√©n√©r√©es dynamiquement -->
                </select>

                <label for="edit-card-text">Question / Texte (Ex: PC (GAUCHE) ou Console (DROITE) ?):</label>
                <input type="text" id="edit-card-text" required placeholder="Question / Texte" />

                <label for="edit-card-img">URL de l'Image (Ex: https://...):</label>
                <input type="url" id="edit-card-img" required placeholder="URL de l'Image" />
                
                <!-- NOUVEAU CHAMP LIEN SOLUCE -->
                <label for="edit-card-soluce-link">Lien Soluce (URL, Optionnel) :</label>
                <input type="url" id="edit-card-soluce-link" placeholder="Lien vers la solution ou la source" />
                <!-- FIN NOUVEAU CHAMP -->

                <label for="edit-card-correct">R√©ponse Correcte :</label>
                <select id="edit-card-correct" required>
                    <option value="left">GAUCHE</option>
                    <option value="right">DROITE</option>
                </select>
            </div>
            
            <!-- Boutons en bas, hors du scroll -->
            <div class="mt-4 flex gap-3 pt-4 border-t border-white/10 flex-shrink-0">
                <button type="button" id="save-card-btn" class="flex-grow py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg font-semibold" onclick="saveCard()">Sauvegarder</button>
                <button type="button" id="btn-delete-card" class="flex-grow py-2 bg-red-600 hover:bg-red-700 rounded-lg font-semibold" onclick="deleteCard()">Supprimer la carte</button>
                <button type="button" onclick="closeEditModal()" class="flex-grow py-2 bg-gray-500 hover:bg-gray-600 rounded-lg">Annuler</button>
            </div>
        </form>
    </div>
  </div>

  <!-- NOUVELLE MODALE D'AJOUT/MODIFICATION DE DECK -->
  <div id="deck-modal" class="base-modal">
    <span class="close-btn" onclick="closeDeckModal()">&times;</span>
    <div id="deck-modal-content" class="w-full max-w-lg text-center flex flex-col">
        <h4 id="deck-modal-title" class="text-2xl font-bold mb-4 flex-shrink-0">Cr√©er un nouveau Deck</h4>
        <form id="deck-form" class="flex flex-col flex-grow min-h-0" onsubmit="return false;">
            
            <div class="flex-grow overflow-y-auto pr-2">
                <!-- Champ cach√© pour l'ID du deck (index) en mode √©dition -->
                <input type="hidden" id="edit-deck-id">
            
                <label for="deck-name">Nom du Deck :</label>
                <input type="text" id="deck-name" required placeholder="Ex: Deck C√©l√©brit√©s" />

                <label for="deck-emoji">Emoji (Ex: üî•) :</label>
                <input type="text" id="deck-emoji" required placeholder="üî•" maxlength="2" />
                
                <label for="deck-indicator-left">Indicateur Gauche (Texte) :</label>
                <input type="text" id="deck-indicator-left" required placeholder="Ex: TRANS" maxlength="10" />
                
                <label for="deck-indicator-right">Indicateur Droit (Texte) :</label>
                <input type="text" id="deck-indicator-right" required placeholder="Ex: GIRL" maxlength="10" />

                <label>Couleur du Deck :</label>
                <div id="deck-color-selector" class="flex justify-center gap-3 mb-4">
                    <div class="color-swatch bg-purple-500" data-color-name="purple"></div>
                    <div class="color-swatch bg-cyan-500" data-color-name="cyan"></div>
                    <div class="color-swatch bg-pink-500" data-color-name="pink"></div>
                    <div class="color-swatch bg-green-500" data-color-name="green"></div>
                    <div class="color-swatch bg-yellow-500" data-color-name="yellow"></div>
                    <div class="color-swatch bg-gray-500" data-color-name="gray"></div>
                    <!-- NOUVELLES COULEURS -->
                    <div class="color-swatch bg-red-500" data-color-name="red"></div>
                    <div class="color-swatch bg-blue-500" data-color-name="blue"></div>
                    <div class="color-swatch bg-indigo-500" data-color-name="indigo"></div>
                    <div class="color-swatch bg-emerald-500" data-color-name="emerald"></div>
                    <div class="color-swatch bg-orange-500" data-color-name="orange"></div>
                </div>
            </div>
            
            <div class="mt-4 flex gap-3 pt-4 border-t border-white/10 flex-shrink-0">
                <button type="button" id="btn-save-deck" onclick="saveDeckInfo()" class="flex-grow py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg font-semibold">Sauvegarder</button>
                <button type="button" onclick="closeDeckModal()" class="flex-grow py-2 bg-gray-500 hover:bg-gray-600 rounded-lg">Annuler</button>
            </div>
        </form>
    </div>
  </div>


  <!-- MODALE PLEIN √âCRAN POUR L'IMAGE -->
  <div id="image-modal" class="base-modal">
    <span class="close-btn" onclick="closeModal()">&times;</span>
    <div id="modal-content">
      <img id="modal-image" src="" alt="Image en grand" />
    </div>
  </div>

  <script>
    const MAX_CARDS = 10;
    const SOLUCE_PASSWORD = "1111"; // MOT DE PASSE SECRET
    let gameData = { score: 0, cardIndex: 0, isProcessing: false };
    let currentDeck = 0;
    let playerName = '';
    let currentFilter = 'all';
    let currentDeckCards = []; // Les 10 cartes tir√©es au sort pour cette partie
    let resultsRecap = []; // MODIFICATION: Tableau pour stocker TOUS les r√©sultats de la partie
    
    // NOUVEAUX √âTATS GLOBAUX
    let isEditingMode = false; 
    let isSoluceLinkMode = false; // Le mode consultation (agrandissement) est le mode par d√©faut

    // Pour l'√©dition: stocke l'ID de la carte en cours d'√©dition (si elle existe)
    let editingCardGlobalId = null; 

    // MODIFICATION: DECK_INFO est maintenant charg√© depuis le localStorage
    const DECKS_KEY = 'torg_game_decks';
    const DECK_INFO_KEY = 'torg_game_deck_info';
    let PERSISTENT_DECKS;
    let PERSISTENT_DECK_INFO;

    // DEFINITION INITIALE DES DECKS (sera migr√©e vers localStorage)
    const DEFAULT_DECK_INFO = [
      { name: "Deck Classic", emoji: "üßúüèª", color: "purple", titleColor: "text-purple-400", cardBorder: "border-purple-400/30", indicatorLeft: "TRANS", indicatorRight: "GIRL" },
      { name: "Deck Hardcore", emoji: "üßöüèª", color: "cyan", titleColor: "text-cyan-400", cardBorder: "border-cyan-400/30", indicatorLeft: "PC", indicatorRight: "CONSOLE" },
      { name: "Deck Cosplay", emoji: "üßùüèª‚Äç‚ôÄÔ∏è", color: "pink", titleColor: "text-pink-400", cardBorder: "border-pink-400/30", indicatorLeft: "COSPLAY", indicatorRight: "IRL" }
    ];

    // DEFINITION INITIALE DES DECKS (sera migr√©e vers localStorage)
    const INITIAL_DECKS = [
      [
        { id: crypto.randomUUID(), text: "Trans or Girl ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Manger de la pizza (GAUCHE) ou faire du sport (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "La Terre est plate (GAUCHE) ou ronde (DROITE) ?", correct: "right", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Voyager dans le pass√© (GAUCHE) ou futur (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Un chat (GAUCHE) ou un chien (DROITE) ?", correct: "right", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Lire un livre (GAUCHE) ou regarder un film (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Montagne (GAUCHE) ou plage (DROITE) ?", correct: "right", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Riche (GAUCHE) ou c√©l√®bre (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Sucr√© (GAUCHE) ou sal√© (DROITE) ?", correct: "right", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "T√©l√©travail (GAUCHE) ou bureau (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        // Ajout de 5 cartes suppl√©mentaires pour plus de rejouabilit√©
        { id: crypto.randomUUID(), text: "Ville (GAUCHE) ou Campagne (DROITE) ?", correct: "left", img: "https://placehold.co/400x550/6B7280/FFFFFF?text=Ville+vs+Campagne", soluceLink: "https://fr.wikipedia.org/wiki/Ville" },
        { id: crypto.randomUUID(), text: "Hiver (GAUCHE) ou √ât√© (DROITE) ?", correct: "right", img: "https://placehold.co/400x550/EAB308/000000?text=Hiver+vs+Ete", soluceLink: "" },
        { id: crypto.randomUUID(), text: "R√©veil matinal (GAUCHE) ou grasse matin√©e (DROITE) ?", correct: "right", img: "https://placehold.co/400x550/F59E0B/FFFFFF?text=Reveil+vs+Grasse+Mat", soluceLink: "" },
        { id: crypto.randomUUID(), text: "√âcrire √† la main (GAUCHE) ou taper (DROITE) ?", correct: "right", img: "https://placehold.co/400x550/A78BFA/FFFFFF?text=Main+vs+Taper", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Voiture (GAUCHE) ou V√©lo (DROITE) ?", correct: "right", img: "https://placehold.co/400x550/3B82F6/FFFFFF?text=Voiture+vs+Velo", soluceLink: "" },
      ],
      [
        { id: crypto.randomUUID(), text: "PC (GAUCHE) ou Console (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Star Wars (GAUCHE) ou Star Trek (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "https://fr.wikipedia.org/wiki/Star_Wars" },
        { id: crypto.randomUUID(), text: "Marvel (GAUCHE) ou DC (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "PlayStation (GAUCHE) ou Xbox (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "iPhone (GAUCHE) ou Android (DROITE) ?", correct: "right", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Dark Mode (GAUCHE) ou Light Mode (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Tabs (GAUCHE) ou Spaces (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Windows (GAUCHE) ou Mac (DROITE) ?", correct: "right", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Netflix (GAUCHE) ou Disney+ (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "RPG (GAUCHE) ou FPS (DROITE) ?", correct: "left", img: "httpsT://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        // Ajout de 5 cartes suppl√©mentaires
        { id: crypto.randomUUID(), text: "Clavier QWERTY (GAUCHE) ou AZERTY (DROITE) ?", correct: "right", img: "https://placehold.co/400x550/DC2626/FFFFFF?text=QWERTY+vs+AZERTY", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Front-end (GAUCHE) ou Back-end (DROITE) ?", correct: "left", img: "https://placehold.co/400x550/3B82F6/FFFFFF?text=Front+vs+Back", soluceLink: "" },
        { id: crypto.randomUUID(), text: "IA (GAUCHE) ou Robotique (DROITE) ?", correct: "left", img: "https://placehold.co/400x550/6B7280/FFFFFF?text=IA+vs+Robots", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Open Source (GAUCHE) ou Propri√©taire (DROITE) ?", correct: "left", img: "https://placehold.co/400x550/22C55E/FFFFFF?text=Open+vs+Proprio", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Manga (GAUCHE) ou Comics (DROITE) ?", correct: "left", img: "https://placehold.co/400x550/F97316/FFFFFF?text=Manga+vs+Comics", soluceLink: "" },
      ],
      [
        { id: crypto.randomUUID(), text: "Caf√© (GAUCHE) ou Th√© (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Matin (GAUCHE) ou Soir (DROITE) ?", correct: "right", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "√ât√© (GAUCHE) ou Hiver (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Ville (GAUCHE) ou Campagne (DROITE) ?", correct: "left", img: "httpsG://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Douche (GAUCHE) ou Bain (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Chiens (GAUCHE) ou Chats (DROITE) ?", correct: "right", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Spotify (GAUCHE) ou Apple Music (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Restaurant (GAUCHE) ou Fast-food (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Voiture (GAUCHE) ou Transports en commun (DROITE) ?", correct: "left", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Sortir (GAUCHE) ou Rester chez soi (DROITE) ?", correct: "right", img: "https://pbs.twimg.com/media/G5KxekAWAAAawBF?format=jpg&name=large", soluceLink: "" },
        // Ajout de 5 cartes suppl√©mentaires
        { id: crypto.randomUUID(), text: "Vivre √† la mer (GAUCHE) ou √† la montagne (DROITE) ?", correct: "right", img: "https://placehold.co/400x550/10B981/FFFFFF?text=Mer+vs+Montagne", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Argent liquide (GAUCHE) ou Carte bancaire (DROITE) ?", correct: "right", img: "https://placehold.co/400x550/FBBF24/000000?text=Cash+vs+Carte", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Voyage en sac √† dos (GAUCHE) ou h√¥tel de luxe (DROITE) ?", correct: "left", img: "httpss://placehold.co/400x550/8B5CF6/FFFFFF?text=Sac+vs+Luxe", soluceLink: "" },
        { id: crypto.randomUUID(), text: "Chocolat noir (GAUCHE) ou au lait (DROITE) ?", correct: "left", img: "https://placehold.co/400x550/78350F/FFFFFF?text=Noir+vs+Lait", soluceLink: "" },
        { id: crypto.randomUUID(), text: "√âcouter de la musique (GAUCHE) ou des podcasts (DROITE) ?", correct: "left", img: "https://placehold.co/400x550/A78BFA/FFFFFF?text=Musique+vs+Podcast", soluceLink: "" },
      ],
    ];
    
    // R√©cup√©ration des √©l√©ments d'√©dition
    const editCardModal = document.getElementById('edit-card-modal');
    const editModalTitle = document.getElementById('edit-modal-title');
    const editCardDeckIndex = document.getElementById('edit-card-deck-index');
    const editCardId = document.getElementById('edit-card-id');
    const editDeckSelect = document.getElementById('edit-deck-select');
    const editCardText = document.getElementById('edit-card-text');
    const editCardImg = document.getElementById('edit-card-img');
    const editCardCorrect = document.getElementById('edit-card-correct');
    const saveCardBtn = document.getElementById('save-card-btn');
    const btnToggleEdit = document.getElementById('btn-toggle-edit');
    const btnDeleteCard = document.getElementById('btn-delete-card');

    // NOUVELLE MODALE DECK
    const deckModal = document.getElementById('deck-modal');
    const deckForm = document.getElementById('deck-form');
    const deckModalTitle = document.getElementById('deck-modal-title');
    const editDeckId = document.getElementById('edit-deck-id');
    const deckNameInput = document.getElementById('deck-name');
    const deckEmojiInput = document.getElementById('deck-emoji');
    const deckIndicatorLeftInput = document.getElementById('deck-indicator-left');
    const deckIndicatorRightInput = document.getElementById('deck-indicator-right');
    const deckColorSelector = document.getElementById('deck-color-selector');


    // ------------------------------------
    // LOGIQUE DE GESTION DU STOCKAGE
    // ------------------------------------
    
    function loadDecks() {
        const storedDecks = localStorage.getItem(DECKS_KEY);
        if (storedDecks) {
            try {
                return JSON.parse(storedDecks);
            } catch (e) {
                console.error("Erreur lors du chargement des decks, r√©initialisation.");
                return migrateInitialDecks();
            }
        }
        return migrateInitialDecks();
    }
    
    // NOUVELLE FONCTION: Charger les Infos des Decks
    function loadDeckInfo() {
        const storedInfo = localStorage.getItem(DECK_INFO_KEY);
        if (storedInfo) {
            try {
                return JSON.parse(storedInfo);
            } catch (e) {
                return migrateInitialDeckInfo();
            }
        }
        return migrateInitialDeckInfo();
    }


    function migrateInitialDecks() {
        // Ajoute un ID unique et un champ soluceLink par d√©faut si manquant
        const decksWithIds = INITIAL_DECKS.map(deck => 
            deck.map(card => ({
                ...card, 
                id: card.id || crypto.randomUUID(),
                soluceLink: card.soluceLink || "" // S'assurer que le champ existe
            }))
        );
        localStorage.setItem(DECKS_KEY, JSON.stringify(decksWithIds));
        return decksWithIds;
    }
    
    // NOUVELLE FONCTION: Migration des Infos de Decks
    function migrateInitialDeckInfo() {
        localStorage.setItem(DECK_INFO_KEY, JSON.stringify(DEFAULT_DECK_INFO));
        return DEFAULT_DECK_INFO;
    }

    function saveDecks(decks) {
        localStorage.setItem(DECKS_KEY, JSON.stringify(decks));
    }
    
    // CORRECTION: Renommage de la fonction de sauvegarde pour √©viter la r√©cursion
    function saveDeckInfoToStorage(info) {
        localStorage.setItem(DECK_INFO_KEY, JSON.stringify(info));
    }
    
    // Fonction principale pour obtenir les decks
    PERSISTENT_DECKS = loadDecks(); 
    PERSISTENT_DECK_INFO = loadDeckInfo();

    // ------------------------------------
    // FIN LOGIQUE DE GESTION DU STOCKAGE
    // ------------------------------------

    const introScreen = document.getElementById('intro-screen');
    const deckScreen = document.getElementById('deck-screen');
    const gameScreen = document.getElementById('game-screen');
    const scoresScreen = document.getElementById('scores-screen');
    const soluceScreen = document.getElementById('soluce-screen'); 
    const publicSoluceScreen = document.getElementById('public-soluce-screen'); // NOUVEAU
    const cardElement = document.getElementById('card');
    const cardImage = document.getElementById('card-image');
    const cardText = document.getElementById('card-text');
    const scoreDisplay = document.getElementById('score-display');
    const indexDisplay = document.getElementById('index-display');
    const endOverlay = document.getElementById('end-overlay');
    const gaugeCircle = document.getElementById('gauge-circle');
    const gaugePercentage = document.getElementById('gauge-percentage');
    const resultMessage = document.getElementById('result-message');
    const messageBox = document.getElementById('message-box');
    const scoresList = document.getElementById('scores-list');
    const playerNameInput = document.getElementById('player-name');
    const playerDisplay = document.getElementById('player-display');
    const overlayLeft = document.getElementById('overlay-left');
    const overlayRight = document.getElementById('overlay-right');
    const indicatorLeft = document.getElementById('indicator-left');
    const indicatorRight = document.getElementById('indicator-right');
    const recapTitle = document.getElementById('recap-title');
    const recapList = document.getElementById('recap-list');
    const imageModal = document.getElementById('image-modal');
    const modalImage = document.getElementById('modal-image');
    const soluceGalleryContainer = document.getElementById('soluce-gallery-container'); 
    const publicSoluceGalleryContainer = document.getElementById('public-soluce-gallery-container');
    const deckSelectionGrid = document.getElementById('deck-selection-grid');
    
    // NOUVEAUX √âL√âMENTS POUR LE MOT DE PASSE
    const passwordModal = document.getElementById('password-modal');
    const passwordInput = document.getElementById('password-input');
    const passwordError = document.getElementById('password-error');
    // NOUVEAU CHAMP LIEN SOLUCE
    const editCardSoluceLink = document.getElementById('edit-card-soluce-link');


    playerName = localStorage.getItem('player_name') || '';
    if (playerName) {
      playerNameInput.value = playerName;
      playerDisplay.textContent = playerName;
    }

    // G√©n√©rer les conteneurs de soluce une seule fois au d√©marrage
    document.addEventListener('DOMContentLoaded', () => {
        // Le code de g√©n√©ration a √©t√© d√©plac√© dans une fonction pour √™tre r√©utilis√© apr√®s l'√©dition
        generateDeckSelectionScreen(PERSISTENT_DECK_INFO, PERSISTENT_DECKS);
        generateSoluceContainers(PERSISTENT_DECKS, PERSISTENT_DECK_INFO);
        generatePublicSoluceContainers(PERSISTENT_DECKS, PERSISTENT_DECK_INFO);
        generateScoreFilters(PERSISTENT_DECK_INFO);
        
        // Ajout de l'√©couteur d'√©v√©nement pour la touche Entr√©e sur le champ de mot de passe
        passwordInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                checkPassword();
            }
        });
        
        // Initialisation des boutons Toggle
        btnToggleEdit.onclick = toggleEditingMode;
        
        // CORRECTION: Assurer que le bouton Admin dans le header est li√©
        const headerAdminBtn = document.getElementById('btn-header-admin');
        if (headerAdminBtn) {
            headerAdminBtn.onclick = openPasswordModal;
        }
        
        // Lier le bouton "Ajouter Deck"
        document.getElementById('btn-add-deck').onclick = () => openDeckModal();
        
        // Lier les clics sur les swatches de couleur
        deckColorSelector.querySelectorAll('.color-swatch').forEach(swatch => {
            swatch.onclick = () => {
                deckColorSelector.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                swatch.classList.add('selected');
            }
        });
    });
    
    // NOUVELLE FONCTION: G√©n√®re l'√©cran de s√©lection de deck
    function generateDeckSelectionScreen(infoData, decksData) {
        deckSelectionGrid.innerHTML = ''; // Vide la grille
        
        infoData.forEach((deckInfo, index) => {
            // S'assurer qu'il y a bien un deck correspondant
            const cardCount = decksData[index] ? decksData[index].length : 0;
            const el = document.createElement('div');
            el.className = `deck-card glass rounded-xl p-6 border-2 ${deckInfo.cardBorder}`;
            el.onclick = () => selectDeck(index);
            
            el.innerHTML = `
              <div class="text-4xl mb-4 text-center">${deckInfo.emoji}</div>
              <h3 class="text-xl font-bold mb-2 text-center ${deckInfo.titleColor}">${deckInfo.name}</h3>
              <p class="text-sm text-gray-300 text-center mb-3">Le deck ${deckInfo.name.toLowerCase()}</p>
              <div class="text-xs text-gray-400 text-center">${cardCount} cartes</div>
            `;
            deckSelectionGrid.appendChild(el);
        });
    }

    // NOUVELLE FONCTION: G√©n√®re les filtres de score
    function generateScoreFilters(infoData) {
        const container = document.getElementById('score-filter-buttons');
        // Vider les anciens filtres (sauf le bouton 'Tous')
        container.querySelectorAll('.filter-btn:not(.active)').forEach(btn => btn.remove());
        
        infoData.forEach((deckInfo, index) => {
            const btn = document.createElement('button');
            btn.className = 'filter-btn px-4 py-2 bg-white/6 border border-white/10 rounded-lg text-sm';
            btn.textContent = `${deckInfo.emoji} ${deckInfo.name}`;
            btn.onclick = (e) => filterScores(index, e);
            container.appendChild(btn);
        });
    }

    
    function generateSoluceContainers(decks, info) {
        soluceGalleryContainer.innerHTML = ''; // Nettoyer l'ancien contenu

        decks.forEach((deck, deckIndex) => {
            const deckInfo = info[deckIndex];
            
            // Cr√©e le titre du Deck
            const titleEl = document.createElement('h4');
            titleEl.className = `soluce-deck-title ${deckInfo.titleColor}`;
            titleEl.innerHTML = `
                ${deckInfo.emoji} ${deckInfo.name} (${deck.length} cartes) 
                <span class="edit-deck-btn" onclick="event.stopPropagation(); openDeckModal(${deckIndex})">‚úèÔ∏è</span>
            `;
            soluceGalleryContainer.appendChild(titleEl);

            // Cr√©e le conteneur sp√©cifique du Deck (qui sera affich√©/cach√©)
            const cardsContainer = document.createElement('div');
            cardsContainer.id = `soluce-deck-${deckIndex}`;
            cardsContainer.className = 'soluce-deck-content hidden-soluce'; // Cach√© par d√©faut
            soluceGalleryContainer.appendChild(cardsContainer);
            
            // Ajoute les cartes au conteneur sp√©cifique
            deck.forEach(card => {
                const el = document.createElement('div');
                el.className = 'soluce-gallery-item flex flex-col justify-between p-2 glass rounded-lg border-2 ' + deckInfo.cardBorder;
                el.setAttribute('data-card-id', card.id);
                el.setAttribute('data-deck-index', deckIndex);
                
                // Le clic sur la vignette g√®re la navigation/√©dition/agrandissement
                el.onclick = () => {
                    if (isEditingMode) {
                        openEditModal(deckIndex, card.id);
                    } else if (card.soluceLink && card.soluceLink.trim() !== "") { // Ouvre le lien si pr√©sent
                        window.open(card.soluceLink, '_blank');
                    } else { 
                        // Mode consultation (agrandissement) SI pas de lien Soluce
                        openModal(card.img);
                    }
                };

                // Conteneur d'image (pour le fond)
                const imageContainer = document.createElement('div');
                imageContainer.className = 'w-full h-2/3 object-cover rounded-md mb-1 soluce-gallery-item-image-container';
                imageContainer.style.backgroundImage = `url('${card.img}')`;
                imageContainer.style.backgroundSize = 'cover';
                imageContainer.style.backgroundPosition = 'center';
                
                // Indicateur de lien Soluce
                if (card.soluceLink && card.soluceLink.trim() !== "") {
                    imageContainer.innerHTML = `<span class="soluce-link-indicator">üîó</span>`;
                }

                // Ajout des informations textuelles
                const correctText = card.correct === 'left' ? 'GAUCHE (Mauve)' : 'DROITE (Rose)';
                const colorClass = card.correct === 'left' ? 'text-purple-400' : 'text-pink-400';
                
                el.appendChild(imageContainer);
                el.innerHTML += `
                    <div class="text-xs font-semibold text-gray-200 truncate" title="${card.text}">${card.text.split(' (')[0]}</div>
                    <div class="text-[10px] ${colorClass}">R√©p: ${correctText}</div>
                    <div class="text-[9px] text-gray-400 mt-0.5">${deckInfo.name}</div>
                `;
                cardsContainer.appendChild(el);
            });
            
            // NOUVEAU: Ajoute la "fausse carte" pour AJOUTER (g√©r√©e par CSS/JS)
            const addCardEl = document.createElement('div');
            addCardEl.className = 'soluce-gallery-item add-card-btn'; // Utilise le style CSS
            addCardEl.style.display = 'none'; // Cach√© par d√©faut, g√©r√© par updateSoluceDisplayModes
            addCardEl.onclick = () => openEditModal(deckIndex, null);
            addCardEl.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
                </svg>
            `;
            cardsContainer.appendChild(addCardEl);
        });
        
        // Appliquer l'√©tat des modes apr√®s le re-rendu
        updateSoluceDisplayModes();
    }
    
    // NOUVELLE FONCTION POUR LA GALERIE PUBLIQUE (consultation uniquement)
    function generatePublicSoluceContainers(decks, info) {
        publicSoluceGalleryContainer.innerHTML = ''; // Nettoyer l'ancien contenu

        decks.forEach((deck, deckIndex) => {
            const deckInfo = info[deckIndex];
            
            // Cr√©e le titre du Deck
            const titleEl = document.createElement('h4');
            titleEl.className = `soluce-deck-title ${deckInfo.titleColor}`;
            titleEl.innerHTML = `${deckInfo.emoji} ${deckInfo.name} (${deck.length} cartes)`;
            publicSoluceGalleryContainer.appendChild(titleEl);

            // Cr√©e le conteneur sp√©cifique du Deck
            const cardsContainer = document.createElement('div');
            cardsContainer.className = 'soluce-deck-content';
            publicSoluceGalleryContainer.appendChild(cardsContainer);
            
            // Ajoute les cartes au conteneur sp√©cifique
            deck.forEach(card => {
                const el = document.createElement('div');
                el.className = 'soluce-gallery-item flex flex-col justify-between p-2 glass rounded-lg border-2 ' + deckInfo.cardBorder;
                
                // MODIFICATION ICI: Le clic ouvre le lien Soluce si pr√©sent, sinon rien.
                el.onclick = () => {
                    if (card.soluceLink && card.soluceLink.trim() !== "") {
                        window.open(card.soluceLink, '_blank');
                    }
                }; 

                // Conteneur d'image (pour le fond)
                const imageContainer = document.createElement('div');
                imageContainer.className = 'w-full h-2/3 object-cover rounded-md mb-1 soluce-gallery-item-image-container';
                imageContainer.style.backgroundImage = `url('${card.img}')`;
                imageContainer.style.backgroundSize = 'cover';
                imageContainer.style.backgroundPosition = 'center';
                
                // Indicateur de lien Soluce (pour information)
                if (card.soluceLink && card.soluceLink.trim() !== "") {
                    imageContainer.innerHTML = `<span class="soluce-link-indicator">üîó</span>`;
                }

                // Ajout des informations textuelles
                const correctText = card.correct === 'left' ? 'GAUCHE (Mauve)' : 'DROITE (Rose)';
                const colorClass = card.correct === 'left' ? 'text-purple-400' : 'text-pink-400';
                
                el.appendChild(imageContainer);
                el.innerHTML += `
                    <div class="text-xs font-semibold text-gray-200 truncate" title="${card.text}">${card.text.split(' (')[0]}</div>
                    <div class="text-[10px] ${colorClass}">R√©p: ${correctText}</div>
                    <div class="text-[9px] text-gray-400 mt-0.5">${deckInfo.name}</div>
                `;
                cardsContainer.appendChild(el);
            });
        });
    }
    
    // ------------------------------------
    // LOGIQUE D'√âDITION DES CARTES
    // ------------------------------------
    
    // NOUVELLE FONCTION: Basculer le mode √©dition
    window.toggleEditingMode = function() {
        isEditingMode = !isEditingMode;
        updateSoluceDisplayModes();
    }

    // NOUVELLE FONCTION: Met √† jour les classes et les textes des boutons
    function updateSoluceDisplayModes() {
        // Logique de mise √† jour des classes des vignettes pour le mode Admin
        // CORRECTION: S'assurer que le s√©lecteur ne prend que les vignettes de carte, pas le bouton "+"
        soluceGalleryContainer.querySelectorAll('.soluce-gallery-item:not(.add-card-btn)').forEach(item => {
            item.classList.remove('editing-mode'); // Seul le mode √©dition est un "mode" sp√©cial
            
            const cardId = item.getAttribute('data-card-id');
            const deckIndex = parseInt(item.getAttribute('data-deck-index'));
            
            // CORRECTION: V√©rifier que deckIndex est un nombre valide avant d'appeler .find()
            if (isNaN(deckIndex) || !PERSISTENT_DECKS[deckIndex]) {
                console.error("Donn√©es de carte invalides pour l'item :", item);
                return; // Ne pas traiter cet √©l√©ment
            }

            const card = PERSISTENT_DECKS[deckIndex].find(c => c.id === cardId);
            const hasSoluceLink = card && card.soluceLink && card.soluceLink.trim() !== "";

            if (isEditingMode) {
                item.classList.add('editing-mode');
                item.onclick = function() { openEditModal(parseInt(this.getAttribute('data-deck-index')), this.getAttribute('data-card-id')); };
            } else if (hasSoluceLink) { 
                 // Mode Soluce (Lien) - Comportement par d√©faut si pas en √©dition
                item.classList.add('soluce-link-mode'); // Conserve la classe pour le contour visuel
                item.onclick = function() {
                    window.open(card.soluceLink, '_blank');
                };
            } else {
                // Mode Consultation (agrandissement) - Comportement par d√©faut si pas en √©dition
                item.classList.remove('soluce-link-mode');
                item.onclick = function() { openModal(card.img); }; // Correction: utiliser card.img
            }
        });
        
        // Mise √† jour des boutons dans l'interface
        if (isEditingMode) {
            btnToggleEdit.textContent = "Quitter l'√©dition";
        } else {
            btnToggleEdit.textContent = "Activer l'√©dition";
        }
        
        // Met √† jour la description d'utilisation
        const infoP = document.querySelector('#soluce-screen p.mb-4');
        if (isEditingMode) {
            infoP.textContent = "Mode √âDITION ACTIF : Cliquez sur une carte pour la modifier ou la supprimer, ou utilisez le bouton 'Ajouter une carte'.";
        } else {
            infoP.textContent = "Mode CONSULTATION : Cliquez sur une carte pour l'agrandir. Si un lien Soluce (üîó) est pr√©sent, le clic ouvrira le lien.";
        }
        
        // G√©rer le bouton Ajouter (visible uniquement en mode √©dition)
        document.querySelectorAll('.add-card-btn').forEach(btn => {
            btn.style.display = isEditingMode ? 'flex' : 'none';
        });
        
        // G√©rer le bouton Ajouter Deck (visible uniquement en mode √©dition)
        document.getElementById('btn-add-deck').style.display = isEditingMode ? 'block' : 'none';
        
        // G√©rer le bouton √âditer Deck (crayon)
        document.querySelectorAll('.edit-deck-btn').forEach(btn => {
            btn.style.display = isEditingMode ? 'inline' : 'none';
        });
    }


    window.openEditModal = function(deckIndex, cardId = null) {
        // Pr√©paration du formulaire pour l'ajout ou l'√©dition
        editingCardGlobalId = cardId;
        passwordModal.classList.remove('active'); // Assurer que la modale de mot de passe est ferm√©e

        // MODIFICATION: Remplir le <select> des decks dynamiquement
        editDeckSelect.innerHTML = '';
        PERSISTENT_DECK_INFO.forEach((info, index) => {
            editDeckSelect.innerHTML += `<option value="${index}">${info.emoji} ${info.name}</option>`;
        });

        if (cardId === null) {
            // MODE AJOUT
            editModalTitle.textContent = 'Ajouter une nouvelle carte';
            editCardId.value = '';
            editCardText.value = '';
            editCardImg.value = '';
            editCardSoluceLink.value = ''; // NOUVEAU
            editCardCorrect.value = 'left';
            editDeckSelect.value = deckIndex !== null ? deckIndex.toString() : '0';
            editDeckSelect.disabled = false;
            btnDeleteCard.style.display = 'none'; // Cacher le bouton supprimer
        } else {
            // MODE √âDITION
            const deck = PERSISTENT_DECKS[deckIndex];
            const card = deck.find(c => c.id === cardId);
            
            if (card) {
                editModalTitle.textContent = 'Modifier la carte existante';
                editCardId.value = cardId;
                editCardDeckIndex.value = deckIndex;
                editCardText.value = card.text;
                editCardImg.value = card.img;
                editCardSoluceLink.value = card.soluceLink || ''; // NOUVEAU
                editCardCorrect.value = card.correct;
                editDeckSelect.value = deckIndex.toString();
                editDeckSelect.disabled = true; // Emp√™che de changer le deck en mode √©dition
                btnDeleteCard.style.display = 'block'; // Montrer le bouton supprimer
            }
        }
        editCardModal.classList.add('active');
    }

    window.closeEditModal = function() {
        editCardModal.classList.remove('active');
    }

    window.saveCard = function() {
        const id = editCardId.value || crypto.randomUUID();
        const deckIndex = parseInt(editDeckSelect.value);
        const text = editCardText.value;
        const img = editCardImg.value;
        const soluceLink = editCardSoluceLink.value.trim(); // NOUVEAU
        const correct = editCardCorrect.value;

        const newCard = { id, text, img, correct, soluceLink };
        
        let decks = loadDecks();
        
        if (editingCardGlobalId) {
            // MODIFICATION (Mise √† jour d'une carte existante)
            const oldDeckIndex = parseInt(editCardDeckIndex.value);
            const cardIndex = decks[oldDeckIndex].findIndex(c => c.id === editingCardGlobalId);
            if (cardIndex !== -1) {
                decks[oldDeckIndex][cardIndex] = newCard;
            }
        } else {
            // AJOUT
            decks[deckIndex].push(newCard);
        }

        saveDecks(decks);
        PERSISTENT_DECKS = decks;
        closeEditModal();
        
        // Rafra√Æchir tous les √©crans qui d√©pendent des decks
        generateSoluceContainers(PERSISTENT_DECKS, PERSISTENT_DECK_INFO); 
        generatePublicSoluceContainers(PERSISTENT_DECKS, PERSISTENT_DECK_INFO);
        generateDeckSelectionScreen(PERSISTENT_DECK_INFO, PERSISTENT_DECKS);
        
        showAllSoluce(); // Afficher la galerie mise √† jour (pour maintenir le contexte Admin)
        return false; // Emp√™che la soumission native du formulaire
    }

    window.deleteCard = function() {
        const cardId = editCardId.value;
        const deckIndex = parseInt(editCardDeckIndex.value);
        
        if (!cardId || isNaN(deckIndex)) return;
        
        if (!confirm("√ätes-vous s√ªr de vouloir supprimer cette carte ?")) return;

        let decks = loadDecks();
        let deletedFromDeckIndex = -1;

        decks[deckIndex] = decks[deckIndex].filter(card => card.id !== cardId);
        deletedFromDeckIndex = deckIndex;

        saveDecks(decks);
        PERSISTENT_DECKS = decks;
        closeEditModal();
        
        // Rafra√Æchir tous les √©crans
        generateSoluceContainers(PERSISTENT_DECKS, PERSISTENT_DECK_INFO);
        generatePublicSoluceContainers(PERSISTENT_DECKS, PERSISTENT_DECK_INFO);
        generateDeckSelectionScreen(PERSISTENT_DECK_INFO, PERSISTENT_DECKS);
        
        showAllSoluce(); // Afficher la galerie mise √† jour (pour maintenir le contexte Admin)
    }
    
    // NOUVELLE FONCTION: Helper pour obtenir les classes de couleur
    function getColorClasses(colorName) {
        const colorMap = {
            "purple": { titleColor: "text-purple-400", cardBorder: "border-purple-400/30" },
            "cyan": { titleColor: "text-cyan-400", cardBorder: "border-cyan-400/30" },
            "pink": { titleColor: "text-pink-400", cardBorder: "border-pink-400/30" },
            "green": { titleColor: "text-green-400", cardBorder: "border-green-400/30" },
            "yellow": { titleColor: "text-yellow-400", cardBorder: "border-yellow-400/30" },
            "gray": { titleColor: "text-gray-400", cardBorder: "border-gray-400/30" },
            "red": { titleColor: "text-red-400", cardBorder: "border-red-400/30" },
            "blue": { titleColor: "text-blue-400", cardBorder: "border-blue-400/30" },
            "indigo": { titleColor: "text-indigo-400", cardBorder: "border-indigo-400/30" },
            "emerald": { titleColor: "text-emerald-400", cardBorder: "border-emerald-400/30" },
            "orange": { titleColor: "text-orange-400", cardBorder: "border-orange-400/30" }
        };
        return colorMap[colorName] || colorMap["gray"];
    }

    // NOUVELLES FONCTIONS D'√âDITION DE DECK
    window.openDeckModal = function(deckIndex = null) {
        // R√©initialiser la s√©lection de couleur
        deckColorSelector.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
        editDeckId.value = '';

        if (deckIndex === null) {
            // MODE AJOUT
            deckModalTitle.textContent = "Cr√©er un nouveau Deck";
            deckNameInput.value = '';
            deckEmojiInput.value = '';
            deckIndicatorLeftInput.value = 'GAUCHE';
            deckIndicatorRightInput.value = 'DROITE';
            // S√©lectionner la premi√®re couleur par d√©faut
            deckColorSelector.querySelector('.color-swatch').classList.add('selected');
        } else {
            // MODE √âDITION
            deckModalTitle.textContent = "Modifier le Deck";
            const deckInfo = PERSISTENT_DECK_INFO[deckIndex];
            editDeckId.value = deckIndex; // Stocke l'index
            deckNameInput.value = deckInfo.name;
            deckEmojiInput.value = deckInfo.emoji;
            deckIndicatorLeftInput.value = deckInfo.indicatorLeft || 'GAUCHE';
            deckIndicatorRightInput.value = deckInfo.indicatorRight || 'DROITE';
            
            // S√©lectionner la couleur enregistr√©e
            const swatch = deckColorSelector.querySelector(`[data-color-name="${deckInfo.color}"]`);
            if (swatch) {
                swatch.classList.add('selected');
            } else {
                deckColorSelector.querySelector('.color-swatch').classList.add('selected'); // Fallback
            }
        }
        deckModal.classList.add('active');
        deckNameInput.focus();
    }
    
    window.closeDeckModal = function() {
        deckModal.classList.remove('active');
    }

    // CORRECTION: Renommage de la fonction de sauvegarde
    window.saveDeckInfo = function() {
        const name = deckNameInput.value.trim();
        const emoji = deckEmojiInput.value.trim();
        const indicatorLeft = deckIndicatorLeftInput.value.trim();
        const indicatorRight = deckIndicatorRightInput.value.trim();
        const selectedColorEl = deckColorSelector.querySelector('.color-swatch.selected');
        const colorName = selectedColorEl ? selectedColorEl.getAttribute('data-color-name') : 'gray';

        if (!name || !emoji || !indicatorLeft || !indicatorRight) {
            alert("Veuillez remplir tous les champs.");
            return false;
        }

        let decks = loadDecks();
        let info = loadDeckInfo();
        const colorClasses = getColorClasses(colorName);
        
        const newDeckInfo = {
            name: name,
            emoji: emoji,
            indicatorLeft: indicatorLeft,
            indicatorRight: indicatorRight,
            color: colorName,
            ...colorClasses
        };

        const deckIndexToEdit = editDeckId.value;

        if (deckIndexToEdit !== "") {
            // MODE √âDITION
            info[parseInt(deckIndexToEdit)] = newDeckInfo;
        } else {
            // MODE AJOUT
            info.push(newDeckInfo);
            decks.push([]); // Ajoute un tableau vide pour les cartes du nouveau deck
        }

        // 4. Sauvegarder
        saveDeckInfoToStorage(info); // CORRECTION: Appel de la fonction renomm√©e
        saveDecks(decks);
        
        PERSISTENT_DECKS = decks;
        PERSISTENT_DECK_INFO = info;

        // 5. Rafra√Æchir toutes les interfaces
        generateDeckSelectionScreen(PERSISTENT_DECK_INFO, PERSISTENT_DECKS);
        generateSoluceContainers(PERSISTENT_DECKS, PERSISTENT_DECK_INFO);
        generatePublicSoluceContainers(PERSISTENT_DECKS, PERSISTENT_DECK_INFO);
        generateScoreFilters(PERSISTENT_DECK_INFO); // Mettre √† jour les filtres de score
        
        closeDeckModal();
        showAllSoluce(); // Rester sur la page Admin
        
        return false; // Emp√™che la soumission native du formulaire
    }
    
    // ------------------------------------
    // FIN LOGIQUE D'√âDITION DES CARTES
    // ------------------------------------
    
    // FONCTIONS MODALES
    window.openModal = function(imageSrc) {
        // Emp√™che l'ouverture de la modale si l'image est le placeholder par d√©faut de "Carte"
        if (imageSrc.includes('Carte') || imageSrc === '') return; 

        modalImage.src = imageSrc;
        imageModal.classList.add('active');
    }

    window.closeModal = function() {
        imageModal.classList.remove('active');
    }
    
    // FONCTIONS MODALES MOT DE PASSE
    window.openPasswordModal = function() {
        passwordInput.value = '';
        passwordError.classList.add('hidden');
        passwordModal.classList.add('active');
        passwordInput.focus();
    }

    window.closePasswordModal = function() {
        passwordModal.classList.remove('active');
    }
    
    window.checkPassword = function() {
        const inputCode = passwordInput.value;
        if (inputCode === SOLUCE_PASSWORD) {
            closePasswordModal();
            showAllSoluce(); // Affiche la soluce compl√®te
        } else {
            passwordError.classList.remove('hidden');
            passwordInput.value = '';
            passwordInput.focus();
        }
    }
    // FIN FONCTIONS MODALES MOT DE PAS PASSE

    // Fermeture de la modale en cliquant sur l'arri√®re-plan
    imageModal.addEventListener('click', (e) => {
        if (e.target.id === 'image-modal') {
            closeModal();
        }
    });
    
    // Fermeture de la modale du mot de passe en cliquant sur l'arri√®re-plan
    passwordModal.addEventListener('click', (e) => {
        if (e.target.id === 'password-modal') {
            closePasswordModal();
        }
    });

    // Fermeture de la modale d'√©dition en cliquant sur l'arri√®re-plan
    editCardModal.addEventListener('click', (e) => {
        if (e.target.id === 'edit-card-modal') {
            closeEditModal();
        }
    });
    
    // Fermeture de la modale d'ajout de deck en cliquant sur l'arri√®re-plan
    deckModal.addEventListener('click', (e) => {
        if (e.target.id === 'deck-modal') {
            closeDeckModal();
        }
    });


    // Fermeture par la touche √âchap (Escape)
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (imageModal.classList.contains('active')) {
                closeModal();
            } else if (passwordModal.classList.contains('active')) {
                 closePasswordModal();
            } else if (editCardModal.classList.contains('active')) {
                 closeEditModal();
            } else if (deckModal.classList.contains('active')) {
                 closeDeckModal();
            }
        }
    });
    
    // NOUVELLE FONCTION: Quitter la partie sans sauvegarder
    window.quitGame = function() {
        showScreen(deckScreen);
    }
    // FIN NOUVELLE FONCTION


    // Fonction de m√©lange Fisher-Yates
    function shuffleArray(array) {
      const newArray = [...array]; 
      for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
      }
      return newArray;
    }

    function saveScore(playerName, deckIndex, errors, percentage) {
      const scores = JSON.parse(localStorage.getItem('game_scores') || '[]');
      scores.unshift({
        player: playerName,
        deck: deckIndex,
        deckName: PERSISTENT_DECK_INFO[deckIndex].name, // Utilise les infos dynamiques
        deckEmoji: PERSISTENT_DECK_INFO[deckIndex].emoji, // Utilise les infos dynamiques
        errors: errors,
        percentage: percentage,
        timestamp: Date.now()
      });
      localStorage.setItem('game_scores', JSON.stringify(scores.slice(0, 100)));
    }

    function getScores() {
      return JSON.parse(localStorage.getItem('game_scores') || '[]');
    }

    function renderScores() {
      const allScores = getScores();
      const filtered = currentFilter === 'all' ? allScores : allScores.filter(s => s.deck === currentFilter);
      scoresList.innerHTML = '';
      if (filtered.length === 0) {
        scoresList.innerHTML = '<div class="text-gray-300 text-center py-6">Aucun score enregistr√©.</div>';
        return;
      }
      filtered.forEach(score => {
        const el = document.createElement('div');
        el.className = 'flex justify-between items-center p-3 bg-white/5 rounded-lg hover:bg-white/8 transition';
        el.innerHTML = `
          <div>
            <div class="flex items-center gap-2 mb-1">
              <span class="text-xl">${score.deckEmoji}</span>
              <span class="font-semibold">${score.player.replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]))}</span>
            </div>
            <div class="text-xs text-gray-400">${new Date(score.timestamp).toLocaleString('fr-FR')}</div>
          </div>
          <div class="text-right">
            <div class="text-2xl font-bold ${score.percentage === 0 ? 'text-green-400' : score.percentage === 100 ? 'text-pink-400' : 'text-purple-400'}">${score.percentage}%</div>
            <div class="text-xs text-gray-400">${score.errors} erreur${score.errors > 1 ? 's' : ''}</div>
          </div>
        `;
        scoresList.appendChild(el);
      });
    }

    // MODIFICATION: Affiche UNIQUEMENT le deck sp√©cifi√© (utilis√© nulle part dans cette version, mais conserv√© pour flexibilit√©)
    window.renderSoluce = function(deckIndex) {
        // Cache tous les conteneurs de soluce
        document.querySelectorAll('.soluce-deck-content').forEach(el => {
            el.classList.add('hidden-soluce');
        });

        // Montre le conteneur du deck sp√©cifi√©
        const targetContainer = document.getElementById(`soluce-deck-${deckIndex}`);
        const targetTitle = targetContainer.previousElementSibling; // Le titre H4 juste avant
        
        if (targetContainer) {
             // Cache tous les titres
            document.querySelectorAll('.soluce-deck-title').forEach(el => el.style.display = 'none');
            
            // Affiche le titre et le contenu du deck actuel
            targetTitle.style.display = 'block';
            targetContainer.classList.remove('hidden-soluce');
        }
        
        // S'assurer que le mode d'√©dition est d√©sactiv√© lorsque l'on arrive sur la page
        isEditingMode = false;
        isSoluceLinkMode = false; // Le mode consultation est le mode par d√©faut √† l'arriv√©e
        
        showScreen(soluceScreen);
    }
    
    // NOUVELLE FONCTION: Affiche l'√©cran de Soluce complet avec tous les decks visibles
    window.showAllSoluce = function() {
        // Montre tous les titres et conteneurs
        document.querySelectorAll('.soluce-deck-title').forEach(el => el.style.display = 'block');
        document.querySelectorAll('.soluce-deck-content').forEach(el => {
            el.classList.remove('hidden-soluce');
        });
        
        // S'assurer que le mode d'√©dition est d√©sactiv√© lorsque l'on arrive sur la page
        isEditingMode = false;

        updateSoluceDisplayModes(); // R√©initialise les modes
        showScreen(soluceScreen);
    }
    
    // NOUVELLE FONCTION pour l'√©cran de soluce public
    window.showPublicSoluce = function() {
        PERSISTENT_DECKS = loadDecks(); 
        PERSISTENT_DECK_INFO = loadDeckInfo();
        generatePublicSoluceContainers(PERSISTENT_DECKS, PERSISTENT_DECK_INFO);
        showScreen(publicSoluceScreen);
    }
    // FIN NOUVELLE FONCTION

    window.filterScores = function(filter, e) {
      currentFilter = filter;
      document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
      (e.target || event.target).classList.add('active'); 
      renderScores();
    }

    // MODIFICATION: Personnalisation des messages par deck
    function getResultMessage(errorPercent) {
        const deckIndex = currentDeck; // R√©cup√®re le deck actuel
        
        // Deck 0: Classic
        if (deckIndex === 0) { 
            if (errorPercent === 0) return { text: "PERFECT! ZERO ERREUR", color: "bg-green-600" };
            if (errorPercent === 100) return { text: "100% GAY", color: "bg-pink-600" };
            if (errorPercent >= 50) return { text: "UN TROU C UN TROU", color: "bg-purple-600" };
            return { text: "PETIT CURIEUX", color: "bg-blue-600" };
        } 
        // Deck 1: Hardcore
        else if (deckIndex === 1) { 
            if (errorPercent === 0) return { text: "Intello du PC!", color: "bg-green-600" };
            if (errorPercent === 100) return { text: "100% Consoleux", color: "bg-red-600" };
            if (errorPercent >= 50) return { text: "Gamer du dimanche", color: "bg-yellow-600" };
            return { text: "Connaisseur", color: "bg-blue-600" };
        }
        // Deck 2: Cosplay
        else if (deckIndex === 2) {
            if (errorPercent === 0) return { text: "Ma√Ætre du d√©guisement", color: "bg-green-600" };
            if (errorPercent === 100) return { text: "A besoin d'une-up", color: "bg-red-600" };
            if (errorPercent >= 50) return { text: "Encore en civil", color: "bg-yellow-600" };
            return { text: "Passionn√© de Pop Culture", color: "bg-blue-600" };
        }
        // Fallback pour les nouveaux decks
        else {
            if (errorPercent === 0) return { text: "PARFAIT !", color: "bg-green-600" };
            if (errorPercent >= 50) return { text: "Peut mieux faire", color: "bg-yellow-600" };
            return { text: "Bien jou√© !", color: "bg-blue-600" };
        }
    }


    function animateCircularGauge(percent) {
      const pct = Math.max(0, Math.min(100, percent));
      gaugePercentage.textContent = pct + '%';
      const circumference = 2 * Math.PI * 80;
      const offset = circumference - (pct / 100) * circumference;
      setTimeout(() => gaugeCircle.style.strokeDashoffset = offset, 100);
      const result = getResultMessage(pct);
      resultMessage.textContent = result.text;
      resultMessage.className = `result-message text-2xl font-bold mb-4 px-4 py-3 rounded-lg ${result.color}`;
    }

    // MODIFICATION: Affichage des r√©sultats SUCCESS et ERROR
    function displayErrorRecap() {
        recapList.innerHTML = '';
        
        // V√©rifie si des cartes ont √©t√© jou√©es
        if (currentDeckCards.length === 0) {
            recapTitle.textContent = "Aucune carte jou√©e dans cette partie.";
            return;
        }

        recapTitle.textContent = "R√©sultat de la partie";

        // Afficher toutes les cartes dans l'ordre o√π elles ont √©t√© jou√©es
        resultsRecap.forEach((playedCard, index) => {
            const card = PERSISTENT_DECKS[currentDeck].find(c => c.id === playedCard.id);
            const status = playedCard.isCorrect ? 'success' : 'error';
            const statusText = playedCard.isCorrect ? 'R√âUSSIE' : 'ERREUR';
            
            const el = document.createElement('div');
            el.className = `result-vignette ${status} flex flex-col items-center justify-between`;
            // MODIFICATION: Le clic ouvre le lien Soluce (si pr√©sent)
            el.onclick = () => {
                if (card.soluceLink && card.soluceLink.trim() !== "") {
                    window.open(card.soluceLink, '_blank');
                }
            };
            if (card.soluceLink && card.soluceLink.trim() !== "") {
                el.style.cursor = 'pointer';
            }

            el.innerHTML = `
                <img src="${card.img}" alt="${statusText}" onerror="this.onerror=null;this.src='https://placehold.co/100x60/${status === 'success' ? '10B981' : 'EF4444'}/FFFFFF?text=${statusText}';" />
                <div class="text-[0.6rem] text-gray-300 truncate w-full mt-0.5">${card.text.split(' (')[0]}</div>
                <!-- MODIFICATION: Texte "R√âUSSIE/ERREUR" supprim√© -->
            `;
            recapList.appendChild(el);
        });
    }

    function showScreen(screenEl) {
      const mainScreens = [introScreen, deckScreen, gameScreen, scoresScreen, soluceScreen, publicSoluceScreen];
      
      mainScreens.forEach(s => {
        s.classList.add('hidden-screen');
        s.style.opacity = 0;
      });

      // S'assurer que les modales sont cach√©es, mais ne pas les inclure dans la logique de 'screen'
      imageModal.classList.remove('active');
      passwordModal.classList.remove('active');
      editCardModal.classList.remove('active');
      deckModal.classList.remove('active'); // NOUVEAU

      screenEl.classList.remove('hidden-screen');
      requestAnimationFrame(() => screenEl.style.opacity = 1);
    }

    function updateUI() {
      scoreDisplay.textContent = gameData.score;
      indexDisplay.textContent = `${Math.min(gameData.cardIndex+1, MAX_CARDS)}/${MAX_CARDS}`;
      const finished = gameData.cardIndex >= MAX_CARDS;
      cardElement.classList.toggle('hidden', finished);
      endOverlay.classList.toggle('hidden', !finished);
      if(finished) animateCircularGauge(Math.round((gameData.score / MAX_CARDS) * 100));
    }

    function displayCard() {
      if(gameData.cardIndex < MAX_CARDS) {
        // Utilise PERSISTENT_DECKS pour r√©cup√©rer la carte actuelle
        const cur = PERSISTENT_DECKS[currentDeck].find(c => c.id === currentDeckCards[gameData.cardIndex].id);
        
        cardImage.src = cur.img;
        cardText.textContent = cur.text;
        
        cardElement.style.transform = 'none';
        cardElement.style.opacity = '1';
        cardElement.classList.remove('slide-out-left','slide-out-right');
        
        // R√©initialise les couleurs et indicateurs visuels
        cardElement.style.borderColor = 'rgba(255,255,255,0.04)'; 
        overlayLeft.style.opacity = '0';
        overlayRight.style.opacity = '0';
        
        // MODIFICATION: Utilise les indicateurs du deck
        const deckInfo = PERSISTENT_DECK_INFO[currentDeck];
        indicatorLeft.innerHTML = deckInfo.indicatorLeft || 'GAUCHE';
        indicatorRight.innerHTML = deckInfo.indicatorRight || 'DROITE';
        
        indicatorLeft.style.opacity = '0';
        indicatorRight.style.opacity = '0';
        indicatorLeft.style.transform = 'translateY(-50%) translateX(0px)';
        indicatorRight.style.transform = 'translateY(-50%) translateX(0px)';
      } else endGame();
    }

    function showMessage(text, type='info') {
      messageBox.textContent = text;
      messageBox.classList.remove('hidden','bg-red-700','bg-green-700','bg-yellow-900','text-yellow-300');
      if(type==='error') messageBox.classList.add('bg-red-700');
      else if(type==='ok') messageBox.classList.add('bg-green-700');
      else messageBox.classList.add('bg-yellow-900','text-yellow-300');
    }

    let startX=0, currentX=0, isDragging=false, isMouseDown=false;
    const SWIPE_THRESHOLD=80, MAX_ROT=15, MAX_DISP=150;

    function updateVisualFeedback(dx) {
        const opacityRatio = Math.min(1, Math.abs(dx) / 100); 

        if (dx < 0) { // Glissement vers la gauche (TRANS/Mauve)
            overlayLeft.style.opacity = (opacityRatio * 0.9).toString();
            overlayRight.style.opacity = '0';
            indicatorLeft.style.opacity = opacityRatio > 0.1 ? '1' : '0';
            indicatorRight.style.opacity = '0';
            indicatorLeft.style.transform = `translateY(-50%) translateX(${Math.min(0, 10 + dx / 5)}px)`;
        } else if (dx > 0) { // Glissement vers la droite (GIRL/Rose)
            overlayRight.style.opacity = (opacityRatio * 0.9).toString();
            overlayLeft.style.opacity = '0';
            indicatorRight.style.opacity = opacityRatio > 0.1 ? '1' : '0';
            indicatorLeft.style.opacity = '0';
            indicatorRight.style.transform = `translateY(-50%) translateX(${Math.max(0, dx / 5 - 10)}px)`;
        } else {
            overlayLeft.style.opacity = '0';
            overlayRight.style.opacity = '0';
            indicatorLeft.style.opacity = '0';
            indicatorRight.style.opacity = '0';
            indicatorLeft.style.transform = 'translateY(-50%) translateX(0px)';
            indicatorRight.style.transform = 'translateY(-50%) translateX(0px)';
        }
    }
    
    // Ajout d'une v√©rification pour emp√™cher le drag si la modale est ouverte
    function isModalOpen() {
        return imageModal.classList.contains('active') || passwordModal.classList.contains('active') || editCardModal.classList.contains('active');
    }

    cardElement.addEventListener('touchstart', e => {
      if(gameData.isProcessing || gameData.cardIndex>=MAX_CARDS || isModalOpen()) return;
      isDragging=true; startX=e.touches[0].clientX; currentX=startX;
      cardElement.style.transition='none'; cardElement.style.cursor='grabbing';
    });

    cardElement.addEventListener('touchmove', e => {
      if(!isDragging || isModalOpen()) return;
      currentX=e.touches[0].clientX;
      const dx=currentX-startX;
      let rot=(dx/MAX_DISP)*MAX_ROT;
      rot=Math.max(-MAX_ROT,Math.min(MAX_ROT,rot));
      cardElement.style.transform = `translateX(${dx}px) rotate(${rot}deg)`;
      updateVisualFeedback(dx); 
    });

    cardElement.addEventListener('touchend', e => {
      if(!isDragging || isModalOpen()) return;
      isDragging=false; cardElement.style.cursor='grab';
      const dx=currentX-startX; startX=0;
      // Ajout d'une condition pour ne pas traiter le touchend comme un swipe si c'est un clic rapide (pour la modale)
      if (Math.abs(dx) < 10) return; 

      cardElement.style.transition='transform .35s cubic-bezier(.22,.9,.27,1), opacity .35s, border-color .3s'; 
      updateVisualFeedback(0); 
      if(dx>SWIPE_THRESHOLD) handleDecision('right');
      else if(dx<-SWIPE_THRESHOLD) handleDecision('left');
      else cardElement.style.transform='none';
    });

    cardElement.addEventListener('mousedown', e => {
      if(gameData.isProcessing || isModalOpen()) return;
      isMouseDown=true; startX=e.clientX; currentX=startX;
      cardElement.style.transition='none'; cardElement.style.cursor='grabbing';
      e.preventDefault();
    });

    document.addEventListener('mousemove', e => {
      if(!isMouseDown || isModalOpen()) return;
      currentX=e.clientX;
      const dx=currentX-startX;
      let rot=(dx/MAX_DISP)*MAX_ROT;
      rot=Math.max(-MAX_ROT,Math.min(MAX_ROT,rot));
      cardElement.style.transform = `translateX(${dx}px) rotate(${rot}deg)`;
      updateVisualFeedback(dx); 
    });

    document.addEventListener('mouseup', e => {
      if(!isMouseDown || isModalOpen()) return;
      isMouseDown=false; cardElement.style.cursor='grab';
      const dx=currentX-startX; startX=0;
      // Ajout d'une condition pour ne pas traiter le mouseup comme un swipe si c'est un clic rapide (pour la modale)
      if (Math.abs(dx) < 10) return; 

      cardElement.style.transition='transform .35s cubic-bezier(.22,.9,.27,1), opacity .35s, border-color .3s'; 
      updateVisualFeedback(0); 
      if(dx>SWIPE_THRESHOLD) handleDecision('right');
      else if(dx<-SWIPE_THRESHOLD) handleDecision('left');
      else cardElement.style.transform='none';
    });

    function handleDecision(decision) {
      if(gameData.isProcessing || gameData.cardIndex>=MAX_CARDS) return;
      gameData.isProcessing=true;
      
      const currentCardRef = currentDeckCards[gameData.cardIndex];
      const cur = PERSISTENT_DECKS[currentDeck].find(c => c.id === currentCardRef.id);
      
      const isCorrect = decision === cur.correct; 
      
      // Stocke le r√©sultat dans le tableau resultsRecap
      currentCardRef.isCorrect = isCorrect; 
      currentCardRef.img = cur.img;
      currentCardRef.text = cur.text;
      
      resultsRecap.push(currentCardRef);
      
      if(!isCorrect) {
        gameData.score++;
        // showMessage('ERREUR! (+1)','error'); // Message supprim√©
        cardElement.style.borderColor = '#EF4444'; // Rouge pour erreur
      } else {
          // showMessage('CORRECT!','ok'); // Message supprim√©
          cardElement.style.borderColor = '#10B981'; // Vert pour correct
      }
      
      // Afficher un flash de couleur pour le d√©grad√© lors de la d√©cision
      if (decision === 'left') {
          overlayLeft.style.opacity = '0.5';
          overlayLeft.style.transition = 'opacity 0.2s ease-out';
      } else {
          overlayRight.style.opacity = '0.5';
          overlayRight.style.transition = 'opacity 0.2s ease-out';
      }
      
      const slideClass = decision==='left' ? 'slide-out-left' : 'slide-out-right';
      cardElement.classList.add(slideClass);
      
      setTimeout(() => {
        cardElement.classList.remove(slideClass);
        gameData.cardIndex++;
        
        // R√©initialisation des d√©grad√©s apr√®s le slide
        overlayLeft.style.opacity = '0';
        overlayRight.style.opacity = '0';
        overlayLeft.style.transition = 'opacity 0.1s linear';
        overlayRight.style.transition = 'opacity 0.1s linear';
        
        setTimeout(() => {
          messageBox.classList.add('hidden');
          messageBox.classList.remove('bg-green-700','bg-red-700');
        }, 900);
        if(gameData.cardIndex<MAX_CARDS) {
          updateUI();
          displayCard();
          gameData.isProcessing=false;
        } else endGame();
      }, 360);
    }

    function continueToDecks() {
      playerName = (playerNameInput.value||'').trim();
      if(!playerName) {
        playerNameInput.focus();
        playerNameInput.classList.add('border-red-500');
        return;
      }
      playerNameInput.classList.remove('border-red-500');
      localStorage.setItem('player_name', playerName);
      playerDisplay.textContent = playerName;
      showScreen(deckScreen);
    }

    window.selectDeck = function(deckIndex) {
      currentDeck = deckIndex;
      startGame();
    }

    function startGame() {
        resultsRecap = []; // MODIFICATION: R√©initialise TOUS les r√©sultats
        
        // 1. Utilise PERSISTENT_DECKS mis √† jour
        const fullDeck = PERSISTENT_DECKS[currentDeck];
        const shuffledDeck = shuffleArray(fullDeck);
        
        // 2. Tire seulement les 10 premi√®res cartes
        // Stocke une r√©f√©rence ID unique pour que la carte soit trouv√©e m√™me si elle est modifi√©e
        currentDeckCards = shuffledDeck.slice(0, MAX_CARDS).map(c => ({ id: c.id })); 
        
      gameData = { score: 0, cardIndex: 0, isProcessing: false };
      updateUI();
      displayCard();
      showScreen(gameScreen);
    }

    function endGame() {
      gameData.isProcessing=true;
      updateUI();
      const pct = Math.round((gameData.score / MAX_CARDS) * 100);
      saveScore(playerName, currentDeck, gameData.score, pct);
      displayErrorRecap(); // Affiche le r√©capitulatif
      updateUI();
      gameData.isProcessing=false;
      endOverlay.classList.remove('hidden');
      endOverlay.style.opacity = 1;
    }

    document.getElementById('btn-start').addEventListener('click', continueToDecks);
    document.getElementById('btn-view-scores').addEventListener('click', () => {
      renderScores();
      showScreen(scoresScreen);
    });
    document.getElementById('btn-view-scores-from-deck').addEventListener('click', () => {
      renderScores();
      showScreen(scoresScreen);
    });
    document.getElementById('btn-view-scores-from-game').addEventListener('click', () => {
      renderScores();
      showScreen(scoresScreen);
    });
    document.getElementById('btn-back-from-scores').addEventListener('click', () => showScreen(deckScreen));
    document.getElementById('btn-choose-deck').addEventListener('click', () => {
      endOverlay.classList.add('hidden');
      showScreen(deckScreen);
    });
    document.getElementById('btn-replay').addEventListener('click', () => {
      endOverlay.classList.add('hidden');
      startGame();
    });
    
    // √âv√©nement pour le nouveau bouton "Quitter"
    document.getElementById('btn-quit-game').addEventListener('click', quitGame);
    
    // √âv√©nement pour le bouton Galerie Soluce (public)
    document.getElementById('btn-view-public-soluce').addEventListener('click', showPublicSoluce);
    
    // √âv√©nement pour le bouton ADMIN HEADER
    // (Li√© dans DOMContentLoaded)


    // **********************************************
    // MODIFICATION ICI: Ajout de l'√©v√©nement pour le bouton de retour de la soluce
    document.getElementById('btn-back-from-soluce-admin').addEventListener('click', () => {
        // Redirige vers la page de s√©lection de deck
        showScreen(deckScreen);
    });
    
    document.getElementById('btn-back-from-public-soluce').addEventListener('click', () => {
        // Redirige vers la page de s√©lection de deck
        showScreen(deckScreen);
    });
    // **********************************************

    document.addEventListener('keydown', e => {
      if(!gameScreen.classList.contains('hidden-screen')) {
        // Emp√™che le jeu si la modale est ouverte
        if(isModalOpen()) return;

        if(e.key==='ArrowLeft') handleDecision('left');
        if(e.key==='ArrowRight') handleDecision('right');
      }
    });

    showScreen(introScreen);
  </script>
</body>
</html>
